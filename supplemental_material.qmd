---
title: "Untitled"
execute: 
  echo: false
  warning: false
  
format: 
    pdf:
        latex-tinytex: true
        latex-auto-install: true
        template-partials:
          - title.tex
        self-contained: true
        toc: true
        number-sections: true
        number-depth: 3
        fig-align: center
        fontsize: 10pt
        include-in-header: 
            text: |
                \usepackage{multirow}
        geometry:
          - top=30mm
          - bottom=30mm
          - left=30mm
          - right=30mm
          - heightrounded
---

\noindent \textsuperscript{1} Department of Mathematics and Statistics, University of Calgary

\textsuperscript{2} Faculty of Veterinary Medicine, University of Calgary

\textsuperscript{3} Department of Epidemiology, Biostatistics, and Occupational Health, McGill University

**Correspondence**:

\*Caitlin Ward, Division of Biostatistics, University of Minnesota. Email: ward-c\@umn.edu

```{r}
# load libraries
library(nimble)
library(ggplot2)
library(grid)
library(gridExtra)
library(scales)
library(RColorBrewer)
library(ggpubr)
library(openxlsx)
library(plyr)
library(kableExtra)
library(dplyr)

source('./supplement_helper_functions.R')
source('./simulation_study/scripts/modelCodes.R')

```


## Simulation Study

### Simulation Set-up

```{=tex}
\begin{center}
\begin{table*}[ht!]%
\caption{Parameters used in simulation data generation.\label{tabSimParams}}
\centering
\begin{tabular}{lcll}
\hline \\[-0.35cm]
\textbf{\begin{tabular}[c]{@{}c@{}}Alarm \\ Function\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Smoothing \\ Window\end{tabular}} & \multicolumn{1}{l}{\textbf{\begin{tabular}[l]{@{}l@{}}Baseline\\ Parameters\end{tabular}}} & \multicolumn{1}{l}{\textbf{\begin{tabular}[l]{@{}l@{}}Behavioral Change\\ Parameters\end{tabular}}} \\ \hline \\[-0.35cm]
\multirow{2}{*}{Power} & 14 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & $k = 0.0003$ \\ \cline{2-4} \\[-0.35cm]
& 30 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & $k = 0.00018$ \\ \hline \\[-0.35cm]
\multirow{2}{*}{Threshold} & 14 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\delta = 0.7$\\ $H = 120$\end{tabular} \\ \cline{2-4} \\[-0.35cm]
& 30 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\delta = 0.78$\\ $H = 70$\end{tabular} \\ \hline \\[-0.35cm]
\multirow{2}{*}{Hill} & 14 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\delta = 0.75$\\ $\nu = 5$\\ $x_0 = 150$\end{tabular} \\ \cline{2-4} \\[-0.35cm]
& 30 days & \begin{tabular}[c]{@{}l@{}}$\beta = 0.42$\\ $\gamma = 0.1429$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\delta = 0.85$\\ $\nu = 5$\\ $x_0 = 100$\end{tabular} \\ \hline
\end{tabular}
\end{table*}
\end{center}
```
\pagebreak

#### Simulated Epidemics - 14-day Smoothing

```{r}
#| fig-cap: True alarm functions used and all 50 simulated epidemics from each alarm when alarms were informed by 14-day average incidence.
#| fig-height: 7
#| fig-width: 10

### get parameters for true alarms
paramsTruth <- read.xlsx('./simulation_study/simParamsSummary.xlsx')

N <- 1e6

xAlarm <- 0:400

# True alarm functions used for data generation
trueAlarmPower14 <- powerAlarm(xAlarm, N = N, 
                               k = paramsTruth$k[
                                   (paramsTruth$alarmGen == 'power' & 
                                        paramsTruth$smoothWindow == 14)])

trueAlarmThresh14 <- thresholdAlarm(xAlarm, N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])

trueAlarmHill14 <- hillAlarm(xAlarm, 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])

trueAlarms <- data.frame(xAlarm = rep(xAlarm, 3),
                         trueAlarm = c(trueAlarmPower14,
                                       trueAlarmThresh14,
                                       trueAlarmHill14),
                         alarmGen = c(rep('power', length(xAlarm)),
                                      rep('thresh', length(xAlarm)),
                                      rep('hill', length(xAlarm))))


# get example data
set.seed(1)
simNumber <- round(runif(1, 0.5, 50.5))

nDays <- 100

# get true epidemic curves for each scenario
trueCurvePower14 <- readRDS(paste0('./simulation_study/Data/power_14.rds'))[,1:nDays]
trueCurveThresh14 <- readRDS(paste0('./simulation_study/Data/thresh_14.rds'))[,1:nDays]
trueCurveHill14 <- readRDS(paste0('./simulation_study/Data/hill_14.rds'))[,1:nDays]

trueCurvePower14 <- as.data.frame(trueCurvePower14)
trueCurvePower14$simNumber <- 1:nrow(trueCurvePower14)
trueCurvePower14Long <- reshape(trueCurvePower14, 
                                varying = paste0('Istar[', 1:100, ']'), 
                                v.names = "inc",
                                timevar = "day", 
                                times = paste0('Istar[', 1:100, ']'), 
                                new.row.names = 1:100000,
                                direction = "long")
trueCurvePower14Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurvePower14Long$day))

trueCurveThresh14 <- as.data.frame(trueCurveThresh14)
trueCurveThresh14$simNumber <- 1:nrow(trueCurveThresh14)
trueCurveThresh14Long <- reshape(trueCurveThresh14, 
                                 varying = paste0('Istar[', 1:100, ']'), 
                                 v.names = "inc",
                                 timevar = "day", 
                                 times = paste0('Istar[', 1:100, ']'), 
                                 new.row.names = 1:100000,
                                 direction = "long")
trueCurveThresh14Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurveThresh14Long$day))

trueCurveHill14 <- as.data.frame(trueCurveHill14)
trueCurveHill14$simNumber <- 1:nrow(trueCurveHill14)
trueCurveHill14Long <- reshape(trueCurveHill14, 
                               varying = paste0('Istar[', 1:100, ']'), 
                               v.names = "inc",
                               timevar = "day", 
                               times = paste0('Istar[', 1:100, ']'), 
                               new.row.names = 1:100000,
                               direction = "long")
trueCurveHill14Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurveHill14Long$day))

trueCurvePower14Long$alarmGen <- 'power'
trueCurveThresh14Long$alarmGen <- 'thresh'
trueCurveHill14Long$alarmGen <- 'hill'


trueCurves <- rbind.data.frame(trueCurvePower14Long, 
                               trueCurveThresh14Long,
                               trueCurveHill14Long)

trueAlarms$alarmGen <- factor(trueAlarms$alarmGen,
                              levels = c('power', 'thresh', 'hill'),
                              labels = c('Power', 'Threshold', 'Hill'))

trueCurves$alarmGen <- factor(trueCurves$alarmGen,
                              levels = c('power', 'thresh', 'hill'),
                              labels = c('Power', 'Threshold', 'Hill'))


theme_set(theme_bw() + 
              theme(strip.background = element_rect(fill = 'white'),
                    strip.text = element_text(size = 16),
                    axis.title = element_text(size = 16),
                    axis.text = element_text(size = 14),
                    plot.title = element_text(size = 17, h = 0.5)))

p1 <- ggplot(trueAlarms, aes(x = xAlarm, y = trueAlarm)) +
    geom_line(size = 1) +
    facet_wrap(~alarmGen) +
    labs(x = '14-day average incidence', y = 'Alarm',
         title = 'True alarm functions') + 
    ylim(0, 1)

p2 <- ggplot(trueCurves, aes(x = day, y = inc, group = factor(simNumber))) +
    geom_line(size = 0.8, alpha = 0.5, col = 'grey') +
    facet_wrap(~alarmGen) +
    labs(x = 'Epidemic Time', y = 'Incidence',
         title = 'Simulated epidemic curves') +
    geom_vline(xintercept = 50, linetype = 2) +
    annotate('text', x = 25, y = 550, label='Train', hjust = 0.5, size = 6) +
    annotate('text', x = 75, y = 550, label='Test', hjust = 0.5, size = 6) +
    ylim(0, 570)

grid.arrange(p1, p2, ncol = 1)


```

\pagebreak

#### Simulated Epidemics - 30-day Smoothing

```{r}
#| fig-cap: True alarm functions used and all 50 simulated epidemics from each alarm when alarms were informed by 30-day average incidence.
#| fig-height: 7
#| fig-width: 10

### get parameters for true alarms
paramsTruth <- read.xlsx('./simulation_study/simParamsSummary.xlsx')

N <- 1e6

xAlarm <- 0:400

# True alarm functions used for data generation
trueAlarmPower30 <- powerAlarm(xAlarm, N = N, 
                               k = paramsTruth$k[
                                   (paramsTruth$alarmGen == 'power' & 
                                        paramsTruth$smoothWindow == 30)])

trueAlarmThresh30 <- thresholdAlarm(xAlarm, N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)])

trueAlarmHill30 <- hillAlarm(xAlarm, 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)])

trueAlarms <- data.frame(xAlarm = rep(xAlarm, 3),
                         trueAlarm = c(trueAlarmPower30,
                                       trueAlarmThresh30,
                                       trueAlarmHill30),
                         alarmGen = c(rep('power', length(xAlarm)),
                                      rep('thresh', length(xAlarm)),
                                      rep('hill', length(xAlarm))))


# get example data
set.seed(1)
simNumber <- round(runif(1, 0.5, 50.5))

nDays <- 100

# get true epidemic curves for each scenario
trueCurvePower30 <- readRDS(paste0('./simulation_study/Data/power_30.rds'))[,1:nDays]
trueCurveThresh30 <- readRDS(paste0('./simulation_study/Data/thresh_30.rds'))[,1:nDays]
trueCurveHill30 <- readRDS(paste0('./simulation_study/Data/hill_30.rds'))[,1:nDays]

trueCurvePower30 <- as.data.frame(trueCurvePower30)
trueCurvePower30$simNumber <- 1:nrow(trueCurvePower30)
trueCurvePower30Long <- reshape(trueCurvePower30, 
                                varying = paste0('Istar[', 1:100, ']'), 
                                v.names = "inc",
                                timevar = "day", 
                                times = paste0('Istar[', 1:100, ']'), 
                                new.row.names = 1:100000,
                                direction = "long")
trueCurvePower30Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurvePower30Long$day))

trueCurveThresh30 <- as.data.frame(trueCurveThresh30)
trueCurveThresh30$simNumber <- 1:nrow(trueCurveThresh30)
trueCurveThresh30Long <- reshape(trueCurveThresh30, 
                                 varying = paste0('Istar[', 1:100, ']'), 
                                 v.names = "inc",
                                 timevar = "day", 
                                 times = paste0('Istar[', 1:100, ']'), 
                                 new.row.names = 1:100000,
                                 direction = "long")
trueCurveThresh30Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurveThresh30Long$day))

trueCurveHill30 <- as.data.frame(trueCurveHill30)
trueCurveHill30$simNumber <- 1:nrow(trueCurveHill30)
trueCurveHill30Long <- reshape(trueCurveHill30, 
                               varying = paste0('Istar[', 1:100, ']'), 
                               v.names = "inc",
                               timevar = "day", 
                               times = paste0('Istar[', 1:100, ']'), 
                               new.row.names = 1:100000,
                               direction = "long")
trueCurveHill30Long$day <- as.numeric(gsub('[[:alpha:]]|[[:punct:]]', '', trueCurveHill30Long$day))

trueCurvePower30Long$alarmGen <- 'power'
trueCurveThresh30Long$alarmGen <- 'thresh'
trueCurveHill30Long$alarmGen <- 'hill'


trueCurves <- rbind.data.frame(trueCurvePower30Long, 
                               trueCurveThresh30Long,
                               trueCurveHill30Long)

trueAlarms$alarmGen <- factor(trueAlarms$alarmGen,
                              levels = c('power', 'thresh', 'hill'),
                              labels = c('Power', 'Threshold', 'Hill'))

trueCurves$alarmGen <- factor(trueCurves$alarmGen,
                              levels = c('power', 'thresh', 'hill'),
                              labels = c('Power', 'Threshold', 'Hill'))


theme_set(theme_bw() + 
              theme(strip.background = element_rect(fill = 'white'),
                    strip.text = element_text(size = 16),
                    axis.title = element_text(size = 16),
                    axis.text = element_text(size = 14),
                    plot.title = element_text(size = 17, h = 0.5)))

p1 <- ggplot(trueAlarms, aes(x = xAlarm, y = trueAlarm)) +
    geom_line(size = 1) +
    facet_wrap(~alarmGen) +
    labs(x = '30-day average incidence', y = 'Alarm',
         title = 'True alarm functions') + 
    ylim(0, 1)

p2 <- ggplot(trueCurves, aes(x = day, y = inc, group = factor(simNumber))) +
    geom_line(size = 0.8, alpha = 0.5, col = 'grey') +
    facet_wrap(~alarmGen) +
    labs(x = 'Epidemic Time', y = 'Incidence',
         title = 'Simulated epidemic curves') +
    geom_vline(xintercept = 50, linetype = 2) +
    annotate('text', x = 25, y = 550, label='Train', hjust = 0.5, size = 6) +
    annotate('text', x = 75, y = 550, label='Test', hjust = 0.5, size = 6) +
    ylim(0, 570)

grid.arrange(p1, p2, ncol = 1)


```

\pagebreak

For the simulated epidemics, the true value of the mean infectious period $1/\gamma$ was 7, so a gamma(193, 1350) prior was used for $\gamma$ as this puts 95% prior probability in the mean infectious period between 6 and 8 days.

```{=tex}
\begin{center}
\begin{table*}[ht!]%
\caption{Priors and MCMC specifications used to fit models in simulation study. $\Gamma$ denotes the gamma distribution with shape and rate parameters. $\min(x)$ and $\max(x)$ are the minimum and maximum observed value of the smoothed incidence during the epidemic, respectively. \vspace{3mm}
\label{tabSimParams}}
\centering
\begin{tabular}{lll}
\hline
Model & Priors & MCMC Specifications \\ \hline \\[-0.35cm]
Power alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\\ $k \sim \Gamma(0.1, 0.1)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Threshold alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\\ $\delta \sim \text{Uniform}(0, 1)$\\ $H \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Hill alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\\ $\delta \sim \text{Uniform}(0, 1)$\\ $\nu \sim \text{Uniform}(0, 50)$\\ $x_0 \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Spline alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\\ $b_{1-3} \sim N(0, 100^2)$\\ $\text{knot}_{1-2} \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Gaussian process alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\\ $\sigma \sim \Gamma(150, 50)$\\ $l \sim \text{inv}\Gamma(a, b)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
No behavioral change & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(193, 1350)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 350,000\\ nburn = 50,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Flexible $\beta_t$ & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $b_{1-4} \sim N(0, 100^2)$\\ $\text{knot}_{1-3} \sim \text{Uniform}(1, \tau)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 800,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
\end{tabular}
\end{table*}
\end{center}
```
\pagebreak

### Simulation Results

#### Posterior distributions of parameters

```{r}
### load GR convergence
grAll <- readRDS('./simulation_study/results/grAll.rds')

# which didn't converge
notConverge <- grAll[which(grAll$gr > 1.1),  ]
notConvergeModels <-  notConverge[
    !duplicated(notConverge[,-which(colnames(notConverge) %in% 
                                        c('gr', 'grUpper', 'param'))]),
    c('alarmGen', 'alarmFit', 
      'smoothWindow', 'simNumber')]
notConvergeModels$noConverge <- 1

### load truth
paramsTruth <- read.xlsx('./simulation_study/simParamsSummary.xlsx')

### wide to long
paramsTruth <- reshape(paramsTruth, 
                       varying = c("beta", "delta", "H", "nu", "x0", "k", "rateI"), 
                       v.names = "truth",
                       timevar = "param", 
                       times = c("beta", "delta", "H", "nu", "x0", "k", "rateI"), 
                       new.row.names = 1:1000,
                       direction = "long")

paramsTruth <- paramsTruth[-which(is.na(paramsTruth$truth)),]
paramsTruth <- paramsTruth[order(paramsTruth$alarmGen,
                                 paramsTruth$smoothWindow,
                                 paramsTruth$param),]
paramsTruth <- paramsTruth[-which(colnames(paramsTruth) %in% c('infPeriod', 'id'))]

paramsPostAll <- readRDS('./simulation_study/results/paramsPostAll.rds')

## remove those that did not converge
paramsPostAll <- merge(paramsPostAll, notConvergeModels,
                       by = c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber'),
                       all.x = T)
paramsPostAll$noConverge[is.na(paramsPostAll$noConverge)] <- 0
paramsPostAll <- paramsPostAll[paramsPostAll$noConverge == 0,]

# merge with truth
paramsPostAll <- merge(paramsPostAll, paramsTruth, 
                       by = c('param', 'alarmGen', 'smoothWindow'),
                       all.x = T)

paramsPostAll <- paramsPostAll[order(paramsPostAll$alarmGen, 
                                     paramsPostAll$smoothWindow,
                                     paramsPostAll$simNumber, 
                                     paramsPostAll$param),]

paramsPostAll$param <- factor(paramsPostAll$param, 
                              levels=c('beta', 'rateI', 
                                       'delta', 'H', 'k', 
                                       'nu', 'x0', 
                                       'b[1]', 'b[2]', 'b[3]', 'b[4]',
                                       'knots[1]', 'knots[2]', 'knots[3]',
                                       'l', 'sigma'),
                              labels=c('beta', 'gamma',
                                       'delta', 'H', 'k', 
                                       'nu', 'x_0', 
                                       'b[1]', 'b[2]', 'b[3]', 'b[4]',
                                       'knots[1]', 'knots[2]', 'knots[3]',
                                       'l', 'sigma'))

paramsPostAll$smoothWindow <- factor(paramsPostAll$smoothWindow , 
                                     labels=c('14-day average', 
                                              '30-day average'))

paramsPostAll$alarmGen <- factor(paramsPostAll$alarmGen,
                                 levels = c('power', 'thresh', 'hill'),
                                 labels = c('Data gen: Power',
                                            'Data gen: Threshold',
                                            'Data gen: Hill'))

```

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in power alarm across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 4
#| fig-width: 9

ggplot(data = subset(paramsPostAll, alarmFit == 'power'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_wrap(smoothWindow ~ param, nrow = 2, scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value, param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = 'Power Alarm') +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in threshold alarm across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 4
#| fig-width: 10

ggplot(data = subset(paramsPostAll, alarmFit == 'thresh'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_wrap(smoothWindow ~ param, nrow = 2, scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value, param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = 'Threshold Alarm') +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

\pagebreak

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in Hill alarm across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 5
#| fig-width: 10

ggplot(data = subset(paramsPostAll, alarmFit == 'hill'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_wrap(smoothWindow ~ param, nrow = 2, scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value, param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = 'Hill Alarm') +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in spline alarm across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 11
#| fig-width: 10

ggplot(data = subset(paramsPostAll, alarmFit == 'spline'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_grid(param ~ alarmGen + smoothWindow,  scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value,
                                    param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = 'Spline Alarm') +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text.x = element_text(size = 10),
          strip.text.y = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in Gaussian process alarm across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 11
#| fig-width: 10

ggplot(data = subset(paramsPostAll, alarmFit == 'gp'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_grid(param ~ alarmGen + smoothWindow,  scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value,
                                    param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = 'Gaussian Process Alarm') +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text.x = element_text(size = 10),
          strip.text.y = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

```{r}
#| fig-cap: Posterior means and 95\% credible intervals for parameters in flexible $\beta_t$ model across 50 simulated epidemics. Red dashed line indicates the true value.
#| fig-height: 11
#| fig-width: 10

ggplot(data = subset(paramsPostAll, alarmFit == 'betatSpline'), 
       aes(x = simNumber, y = mean)) +
    geom_point(size = 1) + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2, size = 1) +
    facet_grid(param ~ alarmGen + smoothWindow,  scales = 'free_y',
               labeller =  labeller(smoothWindow = label_value,
                                    param = label_parsed)) +
    labs(x = 'Simulation Number', y = '',
         title = expression('Flexible' ~ beta[t] ~ 'Model')) +
    theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text.x = element_text(size = 10),
          strip.text.y = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          plot.title = element_text(size = 13, h = 0.5))
```

\pagebreak

#### Results for 14-day incidence

```{r}

paramsTruth <- read.xlsx('./simulation_study/simParamsSummary.xlsx')


N <- 1e6

xAlarm <- 0:500
trueAlarmThresh14 <- thresholdAlarm(xAlarm, N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])
trueAlarmHill14 <- hillAlarm(xAlarm, 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])

trueAlarmPower14 <- powerAlarm(xAlarm, N = N, 
                               k = paramsTruth$k[
                                   (paramsTruth$alarmGen == 'power' & 
                                        paramsTruth$smoothWindow == 14)])

trueAlarms <- data.frame(xAlarm = rep(xAlarm, 3),
                         trueAlarm = c(trueAlarmThresh14,
                                       trueAlarmHill14,
                                       trueAlarmPower14),
                         alarmGen = c(rep('thresh', length(xAlarm)),
                                      rep('hill', length(xAlarm)),
                                      rep('power', length(xAlarm))))

### load posterior estimates
alarmAll <- readRDS('./simulation_study/results/alarmPostAll.rds')

# 14-day smoothing
alarmAll<- subset(alarmAll, smoothWindow == 14)

### remove those that did not converge
alarmAll <- merge(alarmAll, notConvergeModels,
                  by = c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber'),
                  all.x = T)
alarmAll$noConverge[is.na(alarmAll$noConverge)] <- 0
alarmAll <- alarmAll[alarmAll$noConverge == 0,]

# format for better plotting
alarmAll$alarmFit <- factor(alarmAll$alarmFit,
                            levels = c('thresh', 'hill', 'power', 'spline', 'gp'),
                            labels = c('Threshold', 'Hill', 'Power',
                                       'Spline', 'Gaussian Process'))



```

```{r}
#| fig-cap: True and posterior mean estimates of alarm functions from 50 simulated epidemics using the correct parametric function, Spline, and Gaussian Process approaches for model fitting. Models were simulated using 14-day average incidence to inform the alarm function. True alarm functions shown in red.
#| fig-height: 5.5
#| fig-width: 6


theme_set(theme_bw() + 
              theme(strip.background = element_rect(fill = 'white'),
                    strip.text = element_text(size = 9),
                    axis.title = element_text(size = 8),
                    axis.text = element_text(size = 6),
                    plot.title = element_text(size = 9, h = 0.5)))

### smoothing window 14 days
p1 <- ggplot() +  
    geom_line(data = subset(alarmAll, alarmGen == 'power'), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey50', alpha = 0.4)) +
    geom_line(data = subset(trueAlarms, alarmGen == 'power'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red', size = 0.7) +
    facet_wrap(~alarmFit) + 
    labs(x = '14-day average incidence', y = 'Alarm')+
    ylim(0, 1) + 
    ggtitle('Data generation: power alarm')+
    xlim(0, 370)

p2 <- ggplot() +  
    geom_line(data = subset(alarmAll, alarmGen == 'thresh'), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey50', alpha = 0.4)) +
    geom_line(data = subset(trueAlarms, alarmGen == 'thresh'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red', size = 0.7) +
    facet_wrap(~alarmFit) + 
    labs(x = '
         14-day average incidence', y = 'Alarm') +
    ylim(0, 1)  + 
    ggtitle('Data generation: threshold alarm')+
    xlim(0, 250)

p3 <- ggplot() +  
    geom_line(data = subset(alarmAll, alarmGen == 'hill'), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey50', alpha = 0.4)) +
    geom_line(data = subset(trueAlarms, alarmGen == 'hill'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red', size = 0.7) +
    facet_wrap(~alarmFit) + 
    labs(x = '14-day average incidence', y = 'Alarm')+
    ylim(0, 1)  + 
    ggtitle('Data generation: Hill alarm') +
    xlim(0, 300)

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("         Posterior mean of alarm functions", 
                          gp = gpar(fontsize = 10, font = 1)))
```

```{r}
### Posterior prediction 14-day smoothing

# for a randomly selected simulation
set.seed(1)
simNumber <- round(runif(1, 0.5, 50.5))

nDays <- 100

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS('./simulation_study/Data/thresh_14.rds')[simNumber, 1:nDays]
trueCurveHill14 <- readRDS('./simulation_study/Data/hill_14.rds')[simNumber, 1:nDays]
trueCurvePower14 <- readRDS('./simulation_study/Data/power_14.rds')[simNumber, 1:nDays]

trueCurves <- data.frame(time = rep(1:length(trueCurveThresh14), 6),
                         truth = c(trueCurveThresh14, 
                                   trueCurveHill14, 
                                   trueCurvePower14),
                         alarmGen = c(rep('thresh', length(trueCurveThresh14)),
                                      rep('hill', length(trueCurveThresh14)),
                                      rep('power', length(trueCurveThresh14))))

# merge with posterior predictions
postPredAll <- readRDS('./simulation_study/results/postPredAll.rds')
postPredAll<- subset(postPredAll, smoothWindow == 14)

### remove those that did not converge
postPredAll <- merge(postPredAll, notConvergeModels,
                     by = c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber'),
                     all.x = T)
postPredAll$noConverge[is.na(postPredAll$noConverge)] <- 0
postPredAll <- postPredAll[postPredAll$noConverge == 0,]


postPredAll <- postPredAll[postPredAll$simNumber == simNumber,]

# format for better plotting
postPredAll$alarmFit <- factor(postPredAll$alarmFit,
                               levels = c('basic', 'power', 
                                          'thresh', 'hill',
                                          'spline', 'gp'),
                               labels = c('No Behavioral Change', 'Power',
                                          'Threshold', 'Hill',
                                          'Spline', 'Gaussian Process'))


```

```{r}
#| fig-cap: Mean and 95% credible intervals for posterior predictive forecasts of future incidence compared to the truth for a randomly selected simulation.
#| fig-height: 8
#| fig-width: 9

myCol <- 'blue'

theme_set(theme_bw() + 
              theme(strip.background = element_rect(fill = 'white'),
                    strip.text = element_text(size = 11),
                    axis.title = element_text(size = 10),
                    axis.text = element_text(size = 10),
                    plot.title = element_text(size = 11, h = 0.5)))

### 14-day Smoothing Window
p1 <- ggplot() +
    geom_line(data = subset(trueCurves, alarmGen == 'power'),
              aes(x = time, y = truth)) + 
    geom_line(data = subset(postPredAll, alarmGen == 'power'),
              aes(x = time, y = mean), col = myCol, size = 0.5) + 
    geom_ribbon(data=subset(postPredAll, alarmGen == 'power'),
                aes(x = time, ymin = lower, ymax = upper), alpha = 0.3, fill = myCol) +
    facet_wrap(~alarmFit, nrow = 1) +
    labs(x = 'Epidemic time', y = 'Incidence') + 
    ggtitle('Data generation: power alarm')

p2 <- ggplot() +
    geom_line(data = subset(trueCurves, alarmGen == 'thresh'),
              aes(x = time, y = truth)) + 
    geom_line(data = subset(postPredAll, alarmGen == 'thresh'),
              aes(x = time, y = mean), col = myCol, size = 0.5) + 
    geom_ribbon(data=subset(postPredAll, alarmGen == 'thresh'),
                aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = myCol) +
    facet_wrap(~alarmFit, nrow = 1) +
    labs(x = 'Epidemic time', y = 'Incidence') + 
    ggtitle('Data generation: threshold alarm')

p3 <- ggplot() +
    geom_line(data = subset(trueCurves, alarmGen == 'hill'),
              aes(x = time, y = truth)) + 
    geom_line(data = subset(postPredAll, alarmGen == 'hill'),
              aes(x = time, y = mean), col = myCol, size = 0.5) + 
    geom_ribbon(data=subset(postPredAll, alarmGen == 'hill'),
                aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = myCol) +
    facet_wrap(~alarmFit, nrow = 1) +
    labs(x = 'Epidemic time', y = 'Incidence')  + 
    ggtitle('Data generation: Hill alarm')

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("        Posterior predictive forecasting",
                          gp = gpar(fontsize = 13, font = 1)))
```

```{r}
### WAIC Summary table with mean (SD) and % selected 

waicAll <- readRDS('./simulation_study/results/waicAll.rds')
waicAll <- subset(waicAll, smoothWindow == 14)

### remove those that did not converge
waicAll <- merge(waicAll, notConvergeModels,
                 by = c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber'),
                 all.x = T)
waicAll$noConverge[is.na(waicAll$noConverge)] <- 0
waicAll <- waicAll[waicAll$noConverge == 0,]


waicMin <- ddply(waicAll, .(alarmGen, simNumber), summarize,
                 minWAIC = min(waic))

waicAll <- merge(waicAll, waicMin, 
                 by = c('alarmGen', 'simNumber'),
                 all.x = T)

# get mean and sd across simulations
waicSummary <- ddply(waicAll, .(alarmGen, alarmFit), summarize,
                     meanWAIC = mean(waic),
                     sdWAIC = sd(waic))


# get % selected
waicSelected <- ddply(waicAll, .(alarmGen, simNumber), summarize,
                      selected = alarmFit[which(waic == minWAIC)])
waicSelected$selected <- factor(waicSelected$selected,
                                levels = c('power', 'thresh', 'hill',
                                           'spline', 'gp', 'betatSpline', 'basic'))

waicTab <- with(waicSelected, 
                table(selected, alarmGen, exclude = NULL))
waicTab <- as.data.frame(prop.table(waicTab, 2))
colnames(waicTab)[1] <- 'alarmFit'

# merge with other summaries
waicFinal <- merge(waicSummary, 
                   waicTab, by = c('alarmGen', 'alarmFit'))

### format and print
waicFinal$WAIC <- paste0(sprintf("%.2f", round(waicFinal$meanWAIC, 2)), 
                         ' (',
                         sprintf("%.2f", round(waicFinal$sdWAIC, 2)),
                         ')')

waicFinal$Perc <- paste0(round(waicFinal$Freq * 100, 2), '\\%')

waicFinal <- waicFinal[-which(colnames(waicFinal) %in% 
                                  c('sdWAIC', 'Freq'))]
waicFinal$alarmGen <- factor(waicFinal$alarmGen,
                             levels = c('power', 'thresh', 'hill'),
                             labels = c('Power',
                                        'Threshold', 
                                        'Hill'))

waicFinal$alarmFit <- factor(waicFinal$alarmFit,
                             levels = c('power', 'thresh', 'hill',
                                        'spline', 'gp', 'betatSpline', 'basic'),
                             labels = c('Power', 'Threshold', 'Hill',
                                        'Spline', 'Gaussian Process', 
                                        '$\\beta_t$', 'No Behavioral Change'))

waicFinal <- waicFinal[order(waicFinal$alarmGen, 
                             waicFinal$meanWAIC),]
waicFinal <- waicFinal[,-which(colnames(waicFinal) == 'meanWAIC')]

```

```{r}
#| tbl-cap: Summaries of WAIC values across 50 simulated epidemics from three data generation scenarios. Models are ordered by mean WAIC

kable(waicFinal, row.names = F, format = 'latex', align = 'llcc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Data generation}',
                              '\\textbf{Model fitted}', 
                              '\\textbf{WAIC}\n\\textbf{Mean (SD)}',
                              '\\textbf{\\% selected}'), align = 'c')) %>% 
    collapse_rows(columns = 1, latex_hline = 'major') %>%
    kable_styling(latex_options = "HOLD_position")
```

\pagebreak

#### Estimation of $\beta_t$ for flexible model

```{r}

set.seed(2)
simNumber <- round(runif(1, 0.5, 50.5))

times <- 1:50

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS('./simulation_study/Data/thresh_14.rds')[simNumber,times]
trueCurveThresh30 <- readRDS('./simulation_study/Data/thresh_30.rds')[simNumber,times]
trueCurveHill14 <- readRDS('./simulation_study/Data/hill_14.rds')[simNumber,times]
trueCurveHill30 <- readRDS('./simulation_study/Data/hill_30.rds')[simNumber,times]
trueCurvePower14 <- readRDS('./simulation_study/Data/power_14.rds')[simNumber,times]
trueCurvePower30 <- readRDS('./simulation_study/Data/power_30.rds')[simNumber,times]


# using epidemic trajectory and true parameters, find value of alarm[t]/beta[t]
paramsTruth <- read.xlsx('./simulation_study/simParamsSummary.xlsx')

N <- 1e6
trueAlarmThresh14 <- thresholdAlarm(movingAverage(trueCurveThresh14, 14),
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])
trueAlarmThresh30 <- thresholdAlarm(movingAverage(trueCurveThresh30, 30), 
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)])
trueAlarmHill14 <- hillAlarm(movingAverage(trueCurveHill14, 14), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])
trueAlarmHill30 <- hillAlarm(movingAverage(trueCurveHill30, 30), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)])
trueAlarmPower14 <- powerAlarm(movingAverage(trueCurvePower14, 14), 
                               N = N, 
                               k = paramsTruth$k[
                                   (paramsTruth$alarmGen == 'power' & 
                                        paramsTruth$smoothWindow == 14)])
trueAlarmPower30 <- powerAlarm(movingAverage(trueCurvePower30, 30),
                               N = N, 
                               k = paramsTruth$k[
                                   (paramsTruth$alarmGen == 'power' & 
                                        paramsTruth$smoothWindow == 30)])

trueAlarmsSim <- data.frame(time = rep(times, 6),
                            trueAlarm = c(trueAlarmThresh14,
                                          trueAlarmThresh30,
                                          trueAlarmHill14,
                                          trueAlarmHill30,
                                          trueAlarmPower14,
                                          trueAlarmPower30),
                            alarmGen = c(rep('thresh', length(times)*2),
                                         rep('hill', length(times)*2),
                                         rep('power', length(times)*2)),
                            smoothWindow = rep(rep(c(14, 30), each = length(times)), 3))

# from true alarms, get true beta[t]
trueBeta <- trueAlarmsSim
trueBeta$trueBeta <- paramsTruth$beta[1] * (1 - trueBeta$trueAlarm)

### load posterior estimates
betaPostAll <- readRDS('./simulation_study/results/betaPostAll.rds')

### remove those that did not converge
betaPostAll <- merge(betaPostAll, notConvergeModels,
                     by = c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber'),
                     all.x = T)
betaPostAll$noConverge[is.na(betaPostAll$noConverge)] <- 0
betaPostAll <- betaPostAll[betaPostAll$noConverge == 0,]

betaPostAll <- betaPostAll[betaPostAll$simNumber == simNumber,]


betaPostAll$smoothWindow <- factor(betaPostAll$smoothWindow , 
                                   labels=c('14-day average', '30-day average'))
betaPostAll$alarmGen <- factor(betaPostAll$alarmGen, 
                               levels = c('power', 'thresh', 'hill'),
                               labels=c('Power', 'Threshold', 'Hill'))
trueBeta$smoothWindow <- factor(trueBeta$smoothWindow , 
                                labels=c('14-day average', '30-day average'))
trueBeta$alarmGen <- factor(trueBeta$alarmGen, 
                            levels = c('power', 'thresh', 'hill'),
                            labels=c('Power', 'Threshold', 'Hill'))

```

```{r}
#| fig-cap: Posterior distribution of $\beta_t$ for randomly selected simulated epidemics when estimated flexibly with cubic splines. The top row is associated with data generated from the BC model with the alarm based on 14-day average incidence and the bottom row is associated with data generated from the BC model with the alarm based on 30-day average incidence.
#| fig-height: 5
#| fig-width: 7

theme_set(theme_bw() + 
              theme(strip.background = element_rect(fill = 'white'),
                    strip.text = element_text(size = 10),
                    axis.title = element_text(size = 10),
                    axis.text = element_text(size = 8),
                    plot.title = element_text(size = 11, h = 0.5)))

ggplot() +  
    geom_line(data = subset(betaPostAll,), 
              aes(x = time, y = mean, group = simNumber), 
              col = 'orangered', size = 0.8) +
    geom_ribbon(data=subset(betaPostAll),
                aes(x = time, ymin = lower, ymax = upper), 
                alpha = 0.3, fill = 'orangered') +
    geom_line(data = subset(trueBeta), 
              aes(x = time, y = trueBeta), col = 'black') +
    facet_wrap(~smoothWindow + alarmGen, nrow = 2, 
               labeller =  labeller(smoothWindow = label_value, alarmGen = label_parsed)) +
    labs(x = 'Epidemic time', y = expression(beta[t])) +
    ggtitle(expression(paste('Posterior mean and 95% credible intervals for ', beta[t], ' model')))
```


#### Models which did not converge

```{r}
### load GR convergence
grAll <- readRDS('./simulation_study/results/grAll.rds')

# which didn't converge
notConverge <- grAll[which(grAll$gr > 1.1),  ]
notConvergeModels <-  notConverge[
    !duplicated(notConverge[,-which(colnames(notConverge) %in% 
                                        c('gr', 'grUpper', 'param'))]),
    c('alarmGen', 'alarmFit', 
      'smoothWindow', 'simNumber')]
notConvergeModels$noConverge <- 1

rownames(notConvergeModels) <- NULL

notConvergeModels$alarmGen<- factor(notConvergeModels$alarmGen,
                                    levels = c('power', 'thresh', 'hill'),
                                    labels = c('Power', 'Threshold', 'Hill'))


notConvergeModels$alarmFit <- factor(notConvergeModels$alarmFit,
                                     levels = c('power', 'thresh', 'hill',
                                                'spline', 'gp', 'betatSpline', 'basic'),
                                     labels = c('Power', 'Threshold', 'Hill',
                                                'Spline', 'Gaussian Process', 
                                                '$\\beta_t$', 'No Behavioral Change'))


grAll <- grAll[,c('alarmGen', 'alarmFit', 'smoothWindow', 'simNumber', 'param', 'gr')]
grAll$param <- factor(grAll$param, 
                      levels=c('beta', 'rateI', 
                               'delta', 'H', 'k', 
                               'nu', 'x0', 
                               'b[1]', 'b[2]', 'b[3]', 'b[4]', 
                               'knots[1]', 'knots[2]', 'knots[3]', 
                               'l', 'sigma'),
                      labels=c('$\\beta$', '$\\gamma$',
                               '$\\delta$', '$H$', '$k$', 
                               '$\\nu$', '$x_0$', 
                               '$b_1$', '$b_2$', '$b_3$', '$b_4$', 
                               '$knots_1$', '$knots_2$', '$knots_3$', 
                               '$l$', '$\\sigma$'))


# break into two tables
notConvergePrint1 <- notConvergeModels[1:30,-5]
notConvergePrint2 <- notConvergeModels[31:nrow(notConvergeModels),-5]

```

```{r}
#| tbl-cap: List of models from the simulation study which did not converge. Part 1.

kable(notConvergePrint1, row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Data generation}',
                              '\\textbf{Model fitted}', 
                              '\\textbf{Smoothing}\n\\textbf{window}',
                              '\\textbf{Simulation}\n\\textbf{number}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")
```

\pagebreak

```{r}
#| tbl-cap: List of models from the simulation study which did not converge. Part 2.


# break into two tables
kable(notConvergePrint2, row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Data generation}',
                              '\\textbf{Model fitted}', 
                              '\\textbf{Smoothing}\n\\textbf{window}',
                              '\\textbf{Simulation}\n\\textbf{number}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")
```

Tables X - X and Figures 12 - 14 show a sampling of trace plots for models that
did not achieve a Gelman-Rubin diagnostic < 1.1 for all parameters to 
illustrate common convergence issues.

\pagebreak

##### Data: Power, Model: Spline, Smoothing: 14 days, Simulation: 13

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Power, Model: Spline, Smoothing: 14 days, Simulation: 13."

grPrint <- grAll[grAll$alarmGen == 'power' & 
                     grAll$alarmFit == 'spline' & 
                     grAll$smoothWindow ==14 & 
                     grAll$simNumber == 13,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Power, Model: Spline, Smoothing: 14 days, Simulation: 13."
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_power_spline_14_13.rds')

plotSplineChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Data: Power, Model: Spline, Smoothing: 14 days, Simulation: 13."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Data: Threshold, Model: Gaussian Process, Smoothing: 14 days, Simulation: 24

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Threshold, Model: Gaussian Process, Smoothing: 14 days, Simulation: 24."

grPrint <- grAll[grAll$alarmGen == 'thresh' & 
                     grAll$alarmFit == 'gp' & 
                     grAll$smoothWindow ==14 & 
                     grAll$simNumber == 24,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Threshold, Model: Gaussian Process, Smoothing: 14 days, Simulation: 24."
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_thresh_gp_14_24.rds')

plotGPChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Data: Threshold, Model: Gaussian Process, Smoothing: 14 days, Simulation: 24."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Data: Power, Model: $\beta_t$, Smoothing: 14 days, Simulation: 7

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Power, Model: beta[t], Smoothing: 14 days, Simulation: 7."

grPrint <- grAll[grAll$alarmGen == 'power' & 
                     grAll$alarmFit == 'betatSpline' & 
                     grAll$smoothWindow == 14 & 
                     grAll$simNumber == 7,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Power, Model: beta[t],  Smoothing: 14 days, Simulation: 7."
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_power_betatSpline_14_7.rds')

plotBetatChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the $beta_t$ function from each chain. Data: Power, Model: beta[t],  Smoothing: 14 days, Simulation: 7."
#| fig-height: 4
#| fig-width: 7

plotBetaChains(chains)
```

\pagebreak

##### Data: Threshold, Model: $\beta_t$, Smoothing: 14 days, Simulation: 1

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Threshold, Model: beta[t], Smoothing: 14 days, Simulation: 1."

grPrint <- grAll[grAll$alarmGen == 'thresh' & 
                     grAll$alarmFit == 'betatSpline' & 
                     grAll$smoothWindow == 14 & 
                     grAll$simNumber == 1,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Threshold, Model: beta[t], Smoothing: 14 days, Simulation: 1."
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_thresh_betatSpline_14_1.rds')

plotBetatChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the $beta_t$ function from each chain. Data: Threshold, Model: beta[t], Smoothing: 14 days, Simulation: 1."
#| fig-height: 4
#| fig-width: 7

plotBetaChains(chains)
```

\pagebreak

##### Data: Hill, Model: $\beta_t$, Smoothing: 14 days, Simulation: 1

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Hill, Model: beta[t], Smoothing: 14 days, Simulation: 1"

grPrint <- grAll[grAll$alarmGen == 'hill' & 
                     grAll$alarmFit == 'betatSpline' & 
                     grAll$smoothWindow == 14 & 
                     grAll$simNumber == 1,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Hill, Model: beta[t], Smoothing: 14 days, Simulation: 1"
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_hill_betatSpline_14_1.rds')

plotBetatChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the $beta_t$ function from each chain. Data: Hill, Model: beta[t], Smoothing: 14 days, Simulation: 1"
#| fig-height: 4
#| fig-width: 7

plotBetaChains(chains)
```

\pagebreak

##### Data: Threshold, Model: $\beta_t$, Smoothing: 30 days, Simulation: 1

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Data: Threshold, Model: beta[t], Smoothing: 30 days, Simulation: 1."

grPrint <- grAll[grAll$alarmGen == 'thresh' & 
                     grAll$alarmFit == 'betatSpline' & 
                     grAll$smoothWindow == 30 & 
                     grAll$simNumber == 1,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Data: Threshold, Model: beta[t], Smoothing: 30 days, Simulation: 1."
#| fig-height: 4
#| fig-width: 7

chains <- readRDS('./simulation_study/output/chains_thresh_betatSpline_30_1.rds')

plotBetatChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the $beta_t$ function from each chain. Data: Threshold, Model: beta[t], Smoothing: 30 days, Simulation: 1."
#| fig-height: 4
#| fig-width: 7

plotBetaChains(chains)
```

\pagebreak

## Data Application - COVID-19

```{r}
### Pull in all results and format

################################################################################
# Gelman Rubin

grAll <- readRDS('./data_analysis_covid/results/grAll.rds')
grAll <- subset(grAll, peak %in% c(1,2))

# which didn't converge
notConverge <- grAll[which(grAll$gr > 1.1),  ]
notConvergeModels <- notConverge[
    !duplicated(notConverge
                [,-which(colnames(notConverge) %in% c('gr', 'grUpper', 'param'))]),
    c('alarmFit', 'smoothWindow', 'prior', 'peak')]
notConvergeModels$noConverge <- 1


################################################################################
# WAIC

### load WAIC values
waicAll <- readRDS('./data_analysis_covid/results/waicAll.rds')
waicAll <- subset(waicAll, peak %in% c(1,2))

### flag those that did not converge
waicAll <- merge(waicAll, notConvergeModels,
                 by = c('alarmFit', 'smoothWindow', 'prior', 'peak'),
                 all.x = T)
waicAll$noConverge[is.na(waicAll$noConverge)] <- 0
waicAll <- waicAll[order(waicAll$peak, waicAll$waic),]

waicAll$alarmFit <- factor(waicAll$alarmFit,
                           levels = c('thresh', 'hill', 'power',
                                      'spline', 'gp',
                                      'betatSpline',  'basic'),
                           labels = c('Threshold', 'Hill', 'Power',
                                      'Spline', 
                                      'Gaussian Process',
                                      'Beta[t]', 'No Behavior Change'))

waicAll$smoothWindow <- factor(waicAll$smoothWindow,
                               levels = c(1, 60, 30),
                               labels = c('None', '60-day', '30-day'))

waicAll$waic[waicAll$noConverge == 1] <- NA

# minimum for each peak
# minimum WAIC within each prior/peak combination
minWAIC <- ddply(subset(waicAll,  noConverge == 0 ), 
                 .(peak, prior), summarize,
                 alarmFit = alarmFit[which.min(waic)],
                 smoothWindow = smoothWindow[which.min(waic)])
minWAIC$isMin <- 1

waicPlot <- merge(waicAll, minWAIC, by = c('peak', 'prior',
                                           'alarmFit', 'smoothWindow'),
                  all.x = T)

waicPlot$isMin <- factor(waicPlot$isMin, 
                         labels = c('Minimum WAIC'))

waicPlot$Prior <- factor(waicPlot$prior, 
                         levels = c(5,2,4,1,3),
                         labels=c('Mean 3', 
                                  'Mean 2, strong','Mean 2, weaker', 
                                  'Mean 4, strong', 'Mean 4, weaker'))

waicPlot$Peak <- factor(waicPlot$peak,
                        labels = paste0('Wave ', 1:2))

################################################################################
# Posterior parameters

## load posterior estimates of parameters
paramsPostAll <- readRDS('./data_analysis_covid/results/paramsPostAll.rds')
paramsPostAll <- subset(paramsPostAll, peak %in% c(1,2))

# remove those that did not converge
paramsPostAll <- merge(paramsPostAll, notConvergeModels,
                       by = c('alarmFit', 'smoothWindow', 'prior', 'peak'),
                       all.x = T)
paramsPostAll$noConverge[is.na(paramsPostAll$noConverge)] <- 0

rateIParams <- paramsPostAll[paramsPostAll$param == 'rateI',]
meanIParams <- rateIParams
meanIParams$mean <- 1/meanIParams$mean
meanIParams$lower <- 1/meanIParams$lower
meanIParams$upper <- 1/meanIParams$upper
meanIParams$param <- 'meanI'

paramsPostAll <- rbind.data.frame(paramsPostAll, meanIParams)
paramsPostAll <- paramsPostAll[-which(paramsPostAll$param == 'rateI'),]


paramsPostAll$Peak <- factor(paramsPostAll$peak,
                             labels = paste0('Wave ', 1:2))

paramsPostAll$param <- factor(paramsPostAll$param, 
                              levels = c("SIR_init[1]", "SIR_init[2]",
                                         "beta", "meanI", 
                                         "b[1]", "b[2]", "b[3]", "b[4]", 
                                         "delta", "H", "k",  
                                         "knots[1]", "knots[2]", "knots[3]",
                                         "l", "nu", "sigma", "x0"))


# fix S0 and I0
paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]'] <-
    paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]'] - 1
paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]'] <-
    paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]'] - 1
paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]'] <-
    paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]'] - 1

paramsPostAll$mean[paramsPostAll$param == 'SIR_init[2]'] <-
    paramsPostAll$mean[paramsPostAll$param == 'SIR_init[2]'] + 1
paramsPostAll$lower[paramsPostAll$param == 'SIR_init[2]'] <-
    paramsPostAll$lower[paramsPostAll$param == 'SIR_init[2]'] + 1
paramsPostAll$upper[paramsPostAll$param == 'SIR_init[2]'] <-
    paramsPostAll$upper[paramsPostAll$param == 'SIR_init[2]'] + 1

# format S0 with no decimals
paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]'] <- 
    round(paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]'])
paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]'] <- 
    round(paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]'])
paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]'] <- 
    round(paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]'])


# format k to 4 decimal places
paramsPostAll$mean[paramsPostAll$param == 'k'] <-
    sprintf('%.4f', paramsPostAll$mean[paramsPostAll$param == 'k'])
paramsPostAll$lower[paramsPostAll$param == 'k'] <- 
    sprintf('%.4f', paramsPostAll$lower[paramsPostAll$param == 'k'])
paramsPostAll$upper[paramsPostAll$param == 'k'] <- 
    sprintf('%.4f', paramsPostAll$upper[paramsPostAll$param == 'k'])


# format everything except S0 and k to 2 decimals
paramsPostAll$mean[!grepl('SIR_init\\[1\\]|k$', paramsPostAll$param)] <-
    sprintf('%.2f', as.numeric(paramsPostAll$mean[!grepl('SIR_init\\[1\\]|k$', 
                                                         paramsPostAll$param)]))
paramsPostAll$lower[!grepl('SIR_init\\[1\\]|k$', paramsPostAll$param)] <- 
    sprintf('%.2f', as.numeric(paramsPostAll$lower[!grepl('SIR_init\\[1\\]|k$',
                                                          paramsPostAll$param)]))
paramsPostAll$upper[!grepl('SIR_init\\[1\\]|k$', paramsPostAll$param)] <- 
    sprintf('%.2f', as.numeric(paramsPostAll$upper[!grepl('SIR_init\\[1\\]|k$',
                                                          paramsPostAll$param)]))

# format S0 in millions with commas
paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]'] <- 
    format(as.numeric(paramsPostAll$mean[paramsPostAll$param == 'SIR_init[1]']), 
           big.mark = ',', trim = T)
paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]'] <- 
    format(as.numeric(paramsPostAll$lower[paramsPostAll$param == 'SIR_init[1]']), 
           big.mark = ',', trim = T)
paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]'] <- 
    format(as.numeric(paramsPostAll$upper[paramsPostAll$param == 'SIR_init[1]']), 
           big.mark = ',', trim = T)

paramsPostAll$mean[paramsPostAll$noConverge == 1] <- '-'
paramsPostAll$lower[paramsPostAll$noConverge == 1] <- '-'
paramsPostAll$upper[paramsPostAll$noConverge == 1] <- '-'

################################################################################
# Posterior alarms

### load posterior estimates of alarm functions
alarmAll <- readRDS('./data_analysis_covid/results/alarmPostAll.rds')
alarmAll <- subset(alarmAll, peak %in% c(1,2))

### remove those that did not converge 
alarmAll <- merge(alarmAll, notConvergeModels,
                  by = c('alarmFit', 'smoothWindow', 'prior', 'peak'),
                  all.x = T)
alarmAll$noConverge[is.na(alarmAll$noConverge)] <- 0


# NA for those that did not converge
alarmAll$mean[alarmAll$noConverge == 1] <- NA
alarmAll$lower[alarmAll$noConverge == 1] <- NA
alarmAll$upper[alarmAll$noConverge == 1] <- NA

alarmAll$prior <- factor(alarmAll$prior, 
                         levels = c(5,2,4,1,3),
                         labels=c('Mean 3', 
                                  'Mean 2, strong','Mean 2, weaker', 
                                  'Mean 4, strong', 'Mean 4, weaker'))

alarmAll$Smoothing <- factor(alarmAll$smoothWindow,
                             labels = c( '30-day', '60-day'))

alarmAll$Peak <- paste0('Wave ', alarmAll$peak)

################################################################################
# Posterior R0(t)

r0All <- readRDS('./data_analysis_covid/results/r0PostAll.rds')
r0All <- subset(r0All, peak %in% c(1,2))

### remove those that did not converge (TEMPORARY)
r0All <- merge(r0All, notConvergeModels,
               by = c('alarmFit', 'smoothWindow', 'prior', 'peak'),
               all.x = T)
r0All$noConverge[is.na(r0All$noConverge)] <- 0


# NA for those that did not converge
r0All$mean[r0All$noConverge == 1] <- NA
r0All$lower[r0All$noConverge == 1] <- NA
r0All$upper[r0All$noConverge == 1] <- NA

r0All <- r0All[order(r0All$alarmFit, 
                     r0All$smoothWindow,
                     r0All$peak, 
                     r0All$time),]

r0All$prior <- factor(r0All$prior, 
                      levels = c(5,2,4,1,3),
                      labels=c('Mean 3', 
                               'Mean 2, strong','Mean 2, weaker', 
                               'Mean 4, strong', 'Mean 4, weaker'))

r0All$Smoothing <- factor(r0All$smoothWindow,
                          labels = c('None', '30-day', '60-day'))

r0All$Peak <- paste0('Wave ', r0All$peak)

# merge with data to get dates

# load data
dat <- read.csv('./data_analysis_covid/Data/nycClean.csv')
dat <- dat[-c(which(dat$peak %in% c(3:4))[1]:nrow(dat)),]

dat$date <- as.Date(dat$date)
dat$smoothedCases <- round(movingAverage(dat$dailyCases, 7))
dat <- dat[dat$date < as.Date('2022-03-15'), ]

### create columns numbering timing of each wave from 0
dat$timePeak2 <- dat$timePeak1 <- NA

# peak 1 time 1 is row 6
dat$timePeak1[6:(max(which(dat$peak == 1)))] <- 1:(max(which(dat$peak == 1)) - 5)

dat$timePeak2[(min(which(dat$peak == 2)) + 1):(max(which(dat$peak == 2)))] <-
    (min(which(dat$peak == 2)) + 1):(max(which(dat$peak == 2))) -
    min(which(dat$peak == 2)) 

r0Peak1 <- subset(r0All, peak == '1')
r0Peak1 <- merge(r0Peak1, dat, 
                 by.x = 'time', by.y = 'timePeak1', 
                 all.x = T)
r0Peak1 <- r0Peak1[,-which(colnames(r0Peak1) %in% paste0('timePeak', 1:2))]

r0Peak2 <- subset(r0All, peak == '2')
r0Peak2 <- merge(r0Peak2, dat, 
                 by.x = 'time', by.y = 'timePeak2', 
                 all.x = T)
r0Peak2 <- r0Peak2[,-which(colnames(r0Peak2) %in% paste0('timePeak', 1:2))]

r0PeakAll <- rbind.data.frame(r0Peak1, r0Peak2)

################################################################################
# Posterior prediction

### load posterior predictive fit
postPredFitAll <- readRDS('./data_analysis_covid/results/postPredFitAll.rds')
postPredFitAll <- subset(postPredFitAll, peak %in% c(1,2))

### remove those that did not converge (TEMPORARY)
postPredFitAll <- merge(postPredFitAll, notConvergeModels,
                        by = c('alarmFit', 'smoothWindow', 'prior', 'peak'),
                        all.x = T)
postPredFitAll$noConverge[is.na(postPredFitAll$noConverge)] <- 0

# NA for those that did not converge
postPredFitAll$mean[postPredFitAll$noConverge == 1] <- NA
postPredFitAll$lower[postPredFitAll$noConverge == 1] <- NA
postPredFitAll$upper[postPredFitAll$noConverge == 1] <- NA

postPredFitAll$prior <- factor(postPredFitAll$prior, 
                               levels = c(5,2,4,1,3),
                               labels=c('Mean 3', 
                                        'Mean 2, strong','Mean 2, weaker', 
                                        'Mean 4, strong', 'Mean 4, weaker'))

postPredFitAll$Smoothing <- factor(postPredFitAll$smoothWindow,
                                   labels = c('None', '30-day', '60-day'))

postPredFitAll$Peak <- paste0('Wave ', postPredFitAll$peak)

# merge with dates from dataset
postPredFitPeak1 <- subset(postPredFitAll, peak == '1')
postPredFitPeak1 <- merge(postPredFitPeak1, dat, 
                          by.x = 'time', by.y = 'timePeak1', 
                          all.x = T)
postPredFitPeak1 <- postPredFitPeak1[,-which(colnames(postPredFitPeak1) %in%
                                                 paste0('timePeak', 1:2))]

postPredFitPeak2 <- subset(postPredFitAll, peak == '2')
postPredFitPeak2 <- merge(postPredFitPeak2, dat, 
                          by.x = 'time', by.y = 'timePeak2', 
                          all.x = T)
postPredFitPeak2 <- postPredFitPeak2[,-which(colnames(postPredFitPeak2) %in%
                                                 paste0('timePeak', 1:2))]

postPredFitPeakAll <- rbind.data.frame(postPredFitPeak1, 
                                       postPredFitPeak2)

################################################################################
# format not converged models and GR for printing

rownames(notConvergeModels) <- NULL


notConvergeModels$alarmFit <- factor(notConvergeModels$alarmFit,
                                     levels = c('power', 'thresh', 'hill',
                                                'spline', 'gp'),
                                     labels = c('Power', 'Threshold',
                                                'Hill', 'Spline',
                                                'Gaussian Process'))

notConvergeModels$prior <- factor(notConvergeModels$prior, 
                                  levels = c(5,2,4,1,3),
                                  labels=c('Mean 3', 
                                           'Mean 2, strong','Mean 2, weaker', 
                                           'Mean 4, strong', 'Mean 4, weaker'))

notConvergeModels <- notConvergeModels[order(notConvergeModels$alarmFit,
                                             notConvergeModels$peak,
                                             notConvergeModels$smoothWindow,
                                             notConvergeModels$prior),]
grAll$param <- factor(grAll$param, 
                      levels=c('SIR_init[1]', 'SIR_init[2]',
                               'beta', 'rateI', 
                               'delta', 'H', 'k', 
                               'nu', 'x0', 
                               'b[1]', 'b[2]', 'b[3]', 'b[4]',
                               'knots[1]', 'knots[2]', 'knots[3]',
                               'l', 'sigma'),
                      labels=c('$S_0$', '$I_0$',
                               '$\\beta$', '$\\gamma$',
                               '$\\delta$', '$H$', '$k$', 
                               '$\\nu$', '$x_0$', 
                               '$b_1$', '$b_2$', '$b_3$', '$b_4$',
                               '$knots_1$', '$knots_2$', '$knots_3$',
                               '$l$', '$\\sigma$'))

################################################################################
# GGplot theme for plots

myTheme <- theme_bw() +
    theme(strip.background = element_rect(color = 'white',
                                          fill = 'white'),
          strip.text.x = element_text(size = 12),
          strip.text.y = element_text(size = 14),
          axis.text.y = element_text(size = 11),
          axis.text.x = element_text(size = 7),
          axis.title = element_text(size = 12),
          legend.text = element_text(size = 12),
          legend.title = element_text(size = 14),
          plot.title = element_text(size = 14, h = 0.5))
```

### Model Specification

```{=tex}
\begin{center}
\begin{table*}[ht!]%
\caption{Priors and MCMC specifications used to fit models in the NYC data analysis. $\Gamma$ denotes the gamma distribution with shape and rate parameters. $\min(x)$ and $\max(x)$ are the minimum and maximum observed value of the smoothed incidence during the epidemic, respectively. \vspace{3mm}
\label{tabSimParams}}
\centering
\begin{tabular}{lll}
\hline
Model & Priors & MCMC Specifications \\ \hline \\[-0.35cm]
Power alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\\ $k \sim \Gamma(0.1, 0.1)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Threshold alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\\ $\delta \sim \text{Uniform}(0, 1)$\\ $H \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Hill alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\\ $\delta \sim \text{Uniform}(0, 1)$\\ $\nu \sim \text{Uniform}(0, 50)$\\ $x_0 \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Spline alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\\ $b_{1-3} \sim N(0, 100^2)$\\ $\text{knot}_{1-2} \sim \text{Uniform}(\min(x), \max(x))$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
Gaussian process alarm & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\\ $\sigma \sim \Gamma(150, 50)$\\ $l \sim \text{inv}\Gamma(a, b)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 500,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm]
No behavioral change & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $\gamma \sim \Gamma(15, 45)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 400,000\\ nburn = 100,000\\ nthin = 10\end{tabular} \\ \hline \\[-0.35cm] 
Flexible $\beta_t$ & \begin{tabular}[c]{@{}l@{}}$\beta \sim \Gamma(0.1, 0.1)$\\ $b_{1-4} \sim N(0, 100^2)$\\ $\text{knot}_{1-3} \sim \text{Uniform}(1, \tau)$\end{tabular} & \begin{tabular}[c]{@{}l@{}}niter = 1,000,000\\ nburn = 600,000\\ nthin = 10\end{tabular} \\ \hline \\
\end{tabular}
\end{table*}
\end{center}
```
Alternate priors considered for $\gamma$ were:

```{=tex}
\begin{itemize}
\item $\gamma \sim \Gamma(209.5, 419)$ (Mean 2, strong)
\item $\gamma \sim \Gamma(14, 28)$ (Mean 2, weaker)
\item $\gamma \sim \Gamma(736, 2944)$ (Mean 4, strong)
\item $\gamma \sim \Gamma(56, 224)$ (Mean 4, weaker)
\end{itemize}
```

### Prior sensitivity analysis

Five different priors were used for $\gamma$. The various priors were specified to correspond to both stronger and weaker priors, centered on different values. Priors were chosen by evaluating the distribution on the scale of $1/\gamma$, which provides the mean length of the infectious periods. The "strong" priors were chosen so that the probability of being $+/-$ 0.5 days from the specified mean was 99.9% and the "weaker" priors were chosen so that this probability was 65%. The prior used in the final analysis was the least informative.

```{r}
#| fig-cap: Priors used for $\gamma$ on the scale of $1/\gamma$
#| fig-height: 5
#| fig-width: 8


pal <- c('black', 'blue3', 'steelblue1', 'firebrick3', 'lightcoral')

# mean 3
bb <- 45
aa <- 1/3 * bb
curve(dgamma(1/x, aa, bb), col = pal[1], lwd = 3,
      cex.lab = 1.2, cex.axis = 1.2,
      from = 0, to = 10, ylim = c(0, 50),
      xlab = 'Density', ylab = 'Mean infectious period')

# mean 2 strong
bb <- 419
aa <- 1/2*bb
curve(dgamma(1/x, aa, bb), add = T, col = pal[2], lwd = 3, lty = 2)

# mean 2 weaker
bb <- 28
aa <- 1/2*bb
curve(dgamma(1/x, aa, bb), add = T, col = pal[3], lwd = 3, lty = 2)

# mean 4 strong
bb <- 2944
aa <- 1/4 * bb
curve(dgamma(1/x, aa, bb), add = T, col = pal[4], lwd = 3, lty = 4)

# mean 4 weaker
bb <- 224
aa <- 1/4 * bb
curve(dgamma(1/x, aa, bb),  add = T, col = pal[5], lwd = 3, lty = 4)

legend('topright', c('Mean 3', 'Mean 2, strong', 'Mean 2, weaker',
                     'Mean 4, strong', 'Mean 4, weaker'),
       col = pal, lwd = 3,
       lty = c(1, 2, 2, 4, 4),
       cex = 1.4)
```

\pagebreak

### WAIC for all models

```{r}
#| fig-cap: WAIC values for all models/priors across each epidemic wave
#| fig-height: 8
#| fig-width: 8

ggplot(waicPlot, 
       aes(x = alarmFit,  y = waic, fill = smoothWindow, col = isMin)) +
    geom_bar(stat = 'identity', position=position_dodge2(padding = 0.1),
             size = 0.7) + 
    facet_grid(Prior ~ Peak, scales = 'free' ) + 
    coord_flip() + 
    scale_fill_manual(values = c('grey30', 'grey70', 'slateblue2'),
                      limits = c('None', '30-day', '60-day'))+
    scale_color_manual(values = c('red'), na.translate = FALSE) +
    theme_bw() + 
    theme(strip.background = element_rect(color = 'white',
                                          fill = 'white'),
          strip.text.x = element_text(size = 13),
          strip.text.y = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.text.x = element_text(size = 8),
          axis.title = element_text(size = 14),
          legend.text = element_text(size = 11),
          legend.title = element_text(size = 13)) + 
    guides(color = guide_legend(override.aes = list(fill = "white"),
                                title = element_blank())) + 
    labs(fill = 'Smoothing',
         x = '', y = 'WAIC')

```

### Results - Power Alarm

#### Parameter estimation, 30-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the power alarm models when 30-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'power', smoothWindows = 30)
```

\pagebreak

#### Parameter estimation, 60-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the power alarm models when 60-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'power', smoothWindows = 60)
```

\pagebreak

#### Alarm estimation

```{r}
#| fig-cap: Posterior estimation of the alarm function for the power alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 5.5
#| fig-width: 9

pal <- c('orangered', 'blue')

ggplot(subset(alarmAll, alarmFit == 'power'),
       aes(x = xAlarm, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak~ prior, scales = 'free_x', independent = "x") +
    labs(x = 'Smoothed incidence', y = 'Alarm') +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    myTheme

```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the power alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'power'),
       aes(x = date, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the power alarm models across all three waves for 30-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'power' & smoothWindow == 30),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = pal[1]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[1]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

```{r}
#| fig-cap: Posterior predictive fit for the power alarm models across all three waves for 60-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'power' & smoothWindow == 60),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.8, color = pal[2]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[2]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '60-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

\pagebreak

#### Models which did not converge

```{r}
kable(notConvergeModels[notConvergeModels$alarmFit == 'Power',][,c(1,4,3,2)], row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Model fitted}', 
                              '\\textbf{Wave}',
                              '\\textbf{Prior}', 
                              '\\textbf{Smoothing}\n\\textbf{window}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position") %>%
    collapse_rows(columns = 1, latex_hline = 'major')

```

\pagebreak

##### Peak 2, Prior: Mean 3, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 3, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 5 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 3, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_30_5.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain.  Model: Power, Peak 2, Prior: Mean 3, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 2, strong, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 2 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_30_2.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 2, weaker, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 4 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_30_4.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 4, weaker, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 3 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_30_3.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 3, 60-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 3, 60-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 5 & 
                     grAll$smoothWindow == 60,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 3, 60-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_60_5.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 3, 60-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 2, strong, 60-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 2, strong, 60-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 2 & 
                     grAll$smoothWindow == 60,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 2, strong, 60-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_60_2.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 2, strong, 60-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 4, weaker, 60-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Power, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'power' & 
                     grAll$peak == 2 & 
                     grAll$prior == 3 & 
                     grAll$smoothWindow == 60,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Power, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_power_peak2_60_3.rds')

plotPowerChains(chains)
```

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Power, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

### Results - Threshold Alarm

#### Parameter estimation, 30-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the threshold alarm models when 30-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'thresh', smoothWindows = 30)
```

\pagebreak

#### Parameter estimation, 60-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the threshold alarm models when 60-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'thresh', smoothWindows = 60)
```

\pagebreak

#### Alarm estimation

```{r}
#| fig-cap: Posterior estimation of the alarm function for the threshold alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 5.5
#| fig-width: 9

pal <- c('orangered', 'blue')

ggplot(subset(alarmAll, alarmFit == 'thresh'),
       aes(x = xAlarm, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak~ prior, scales = 'free_x', independent = "x") +
    labs(x = 'Smoothed incidence', y = 'Alarm') +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    myTheme

```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the threshold alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'thresh'),
       aes(x = date, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the threshold alarm models across all three waves for 30-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'thresh' & smoothWindow == 30),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = pal[1]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[1]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

```{r}
#| fig-cap: Posterior predictive fit for the threshold alarm models across all three waves for 60-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'thresh' & smoothWindow == 60),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.8, color = pal[2]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[2]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '60-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Models which did not converge

```{r}
kable(notConvergeModels[notConvergeModels$alarmFit == 'Threshold',][,c(1,4,3,2)], row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Model fitted}', 
                              '\\textbf{Wave}',
                              '\\textbf{Prior}', 
                              '\\textbf{Smoothing}\n\\textbf{window}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position") %>%
    collapse_rows(columns = 1, latex_hline = 'major')

```

\pagebreak

##### Peak 1, Prior: Mean 4, strong, 60-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Threshold, Peak 1, Prior: Mean 4, strong, 60-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'thresh' & 
                     grAll$peak == 1 & 
                     grAll$prior == 1 & 
                     grAll$smoothWindow == 60,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Threshold, Peak 1, Prior: Mean 4, strong, 60-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_thresh_peak1_60_1.rds')

plotThreshChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Threshold, Peak 1, Prior: Mean 4, strong, 60-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 2, strong, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters.  Model: Threshold, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'thresh' & 
                     grAll$peak == 2 & 
                     grAll$prior == 2 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains.  Model: Threshold, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 3
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_thresh_peak2_30_2.rds')

plotThreshChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Threshold, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 2.8
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

### Results - Hill Alarm

#### Parameter estimation, 30-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the Hill alarm models when 30-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'hill', smoothWindows = 30)
```

\pagebreak

#### Parameter estimation, 60-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the Hill alarm models when 60-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'hill', smoothWindows = 60)
```

\pagebreak

#### Alarm estimation

```{r}
#| fig-cap: Posterior estimation of the alarm function for the Hill alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 5.5
#| fig-width: 9

pal <- c('orangered', 'blue')

ggplot(subset(alarmAll, alarmFit == 'hill'),
       aes(x = xAlarm, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak~ prior, scales = 'free_x', independent = "x") +
    labs(x = 'Smoothed incidence', y = 'Alarm') +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    myTheme

```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the Hill alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'hill'),
       aes(x = date, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the Hill alarm models across all three waves for 30-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'hill' & smoothWindow == 30),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = pal[1]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[1]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

```{r}
#| fig-cap: Posterior predictive fit for the Hill alarm models across all three waves for 60-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'hill' & smoothWindow == 60),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.8, color = pal[2]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[2]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '60-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Models which did not converge

```{r}
kable(notConvergeModels[notConvergeModels$alarmFit == 'Hill',][,c(1,4,3,2)], row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Model fitted}', 
                              '\\textbf{Wave}',
                              '\\textbf{Prior}', 
                              '\\textbf{Smoothing}\n\\textbf{window}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position") %>%
    collapse_rows(columns = 1, latex_hline = 'major')

```

\pagebreak

##### Peak 2, Prior: Mean 2, strong, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Hill, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'hill' & 
                     grAll$peak == 2 & 
                     grAll$prior == 2 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Hill, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 5
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_hill_peak2_30_2.rds')

plotHillChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Hill, Peak 2, Prior: Mean 2, strong, 30-day Smoothing."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 2, weaker, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Hill, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'hill' & 
                     grAll$peak == 2 & 
                     grAll$prior == 4 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Hill, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 5
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_hill_peak2_30_4.rds')

plotHillChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Hill, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 4, weaker, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Hill, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'hill' & 
                     grAll$peak == 2 & 
                     grAll$prior == 3 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Hill, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."
#| fig-height: 5
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_hill_peak2_30_3.rds')

plotHillChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Hill, Peak 2, Prior: Mean 4, weaker, 30-day Smoothing."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

### Results - Spline Alarm

#### Parameter estimation, 30-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the spline alarm models when 30-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'spline', smoothWindows = 30)
```

\pagebreak

#### Parameter estimation, 60-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the Hill alarm models when 60-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'spline', smoothWindows = 60)
```

\pagebreak

#### Alarm estimation

```{r}
#| fig-cap: Posterior estimation of the alarm function for the spline alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 5.5
#| fig-width: 9

pal <- c('orangered', 'blue')

ggplot(subset(alarmAll, alarmFit == 'spline'),
       aes(x = xAlarm, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak~ prior, scales = 'free_x', independent = "x") +
    labs(x = 'Smoothed incidence', y = 'Alarm') +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    myTheme

```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the spline alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'spline'),
       aes(x = date, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the spline alarm models across all three waves for 30-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'spline' & smoothWindow == 30),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = pal[1]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[1]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

```{r}
#| fig-cap: Posterior predictive fit for the spline alarm models across all three waves for 60-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'spline' & smoothWindow == 60),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.8, color = pal[2]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[2]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '60-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Models which did not converge

```{r}
kable(notConvergeModels[notConvergeModels$alarmFit == 'Spline',][,c(1,4,3,2)], row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Model fitted}', 
                              '\\textbf{Wave}',
                              '\\textbf{Prior}', 
                              '\\textbf{Smoothing}\n\\textbf{window}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position") %>%
    collapse_rows(columns = 1, latex_hline = 'major')

```

\pagebreak

##### Peak 2, Prior: Mean 2, weaker, 30-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Spline, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'spline' & 
                     grAll$peak == 2 & 
                     grAll$prior == 4 & 
                     grAll$smoothWindow == 30,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Spline, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 5
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_spline_peak2_30_4.rds')

plotSplineChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Spline, Peak 2, Prior: Mean 2, weaker, 30-day Smoothing."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

##### Peak 2, Prior: Mean 4, weaker, 60-day Smoothing

```{r}
#| tbl-cap: "Gelman-Rubin values for all parameters. Model: Spline, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."

grPrint <- grAll[grAll$alarmFit == 'spline' & 
                     grAll$peak == 2 & 
                     grAll$prior == 3 & 
                     grAll$smoothWindow == 60,]
grPrint$gr <- sprintf("%.2f", round(grPrint$gr, 2))
grPrint <- grPrint[order(grPrint$param),]

kable(grPrint[,c('param', 'gr')], row.names = F, format = 'latex', align = 'lc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Parameter}',
                              '\\textbf{Gelman-Rubin}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position")

```

```{r}
#| fig-cap: "Trace plot for all three chains. Model: Spline, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."
#| fig-height: 5
#| fig-width: 7

chains <- readRDS('./data_analysis_covid/output/chains_spline_peak2_60_3.rds')

plotSplineChains(chains)
```

\pagebreak

```{r}
#| fig-cap: "Posterior mean and 95% credible intervals for the alarm function from each chain. Model: Spline, Peak 2, Prior: Mean 4, weaker, 60-day Smoothing."
#| fig-height: 4
#| fig-width: 7

plotAlarmChains(chains)
```

\pagebreak

### Results - Gaussian Process Alarm

#### Parameter estimation, 30-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the Gaussian process alarm models when 30-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'gp', smoothWindows = 30)
```

\pagebreak

#### Parameter estimation, 60-day smoothing

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the Gaussian process alarm models when 60-day smoothing was used

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'gp', smoothWindows = 60)
```

\pagebreak

#### Alarm estimation

```{r}
#| fig-cap: Posterior estimation of the alarm function for the Gaussian process alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 5.5
#| fig-width: 9

pal <- c('orangered', 'blue')

ggplot(subset(alarmAll, alarmFit == 'gp'),
       aes(x = xAlarm, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak~ prior, scales = 'free_x', independent = "x") +
    labs(x = 'Smoothed incidence', y = 'Alarm') +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    myTheme

```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the Gaussian process alarm models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'gp'),
       aes(x = date, y = mean, col = Smoothing, fill = Smoothing)) +  
    geom_line(size = 0.5) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the Gaussian process alarm models across all three waves for 30-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'gp' & smoothWindow == 30),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = pal[1]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[1]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

```{r}
#| fig-cap: Posterior predictive fit for the Gaussian process alarm models across all three waves for 60-day smoothing. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'gp' & smoothWindow == 60),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.8, color = pal[2]) +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = pal[2]) +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '60-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Models which did not converge

```{r}
kable(notConvergeModels[notConvergeModels$alarmFit == 'Gaussian Process',][,c(1,4,3,2)], row.names = F, format = 'latex', align = 'lccc', 
      booktabs = T, escape = F, 
      col.names = linebreak(c('\\textbf{Model fitted}', 
                              '\\textbf{Wave}',
                              '\\textbf{Prior}', 
                              '\\textbf{Smoothing}\n\\textbf{window}'), align = 'c')) %>% 
    kable_styling(latex_options = "HOLD_position") %>%
    collapse_rows(columns = 1, latex_hline = 'major')

```

\pagebreak

### Results - No Behavioral Change Model

#### Parameter estimation

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the models with no behavioral change.

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'basic', smoothWindows = 1)
```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the models with no behavioral change across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'basic'),
       aes(x = date, y = mean)) +  
    geom_line(size = 0.5, color = 'blue') +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = 'blue') +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the models with no behavioral change across all three waves. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'basic' ),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = 'blue') +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = 'blue') +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

### Results - Flexible $\beta_t$ Model

#### Parameter estimation

```{r}
#| tbl-cap: Posterior mean and 95% credible intervals for all parameters in the flexible $\\beta_t$ models.

postParamTableAlarm(paramsPostAll = paramsPostAll,
                    alarmFits = 'betatSpline', smoothWindows = 1)
```

\pagebreak

#### $\mathcal{R}_0(t)$ estimation

```{r}
#| fig-cap: Posterior estimation of $\mathcal{R}_0(t)$ for the flexible $\beta_t$ models across all three waves. Models that did not converge are not shown.
#| fig-height: 6
#| fig-width: 9

ggplot(subset(r0PeakAll, alarmFit == 'betatSpline'),
       aes(x = date, y = mean)) +  
    geom_line(size = 0.5, color = 'blue') +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = 'blue') +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = expression(R[0](t))) +
    geom_hline(yintercept = 1, linetype = 2) + 
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```

\pagebreak

#### Posterior predictive fit

```{r}
#| fig-cap: Posterior predictive fit for the flexible $\beta_t$ models across all three waves. Models that did not converge are not shown.
#| fig-height: 5
#| fig-width: 9

ggplot(subset(postPredFitPeakAll, alarmFit == 'betatSpline' ),
       aes(x = date, y = mean)) +  
    geom_line(aes(y = smoothedCases), color = 'black', size = 0.5) +
    geom_line(size = 0.7, color = 'blue') +
    geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.3, fill = 'blue') +
    ggh4x::facet_grid2(Peak ~prior, scales = 'free', independent = "x") +
    labs(x = 'Date', y = 'Incidence', title = '30-day smoothing') +
    scale_x_date(date_breaks = "2 month", date_minor_breaks = "1 month",
                 date_labels = "%b '%y") +
    myTheme + 
    theme(axis.text.x = element_text(size = 8, angle = 25, vjust = 1, hjust = 1))
```
