---
title: "BCM Simulation Results"
author: "Caitlin Ward"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width = 14, fig.height = 10)

library(openxlsx)
library(ggplot2)
library(grid)
library(gridExtra)
library(nimble)
library(plyr)
library(knitr)
library(scales)

# functions to calculate the alarms
source('./scripts/modelCodes.R')

theme_set(theme_bw() + 
    theme(strip.background = element_rect(fill = 'white'),
          strip.text = element_text(size = 16),
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 14)))

```

## Gelman Rubin

Number of models remaining with Gelman Rubin > 1.1.

```{r}
grAll <- readRDS('./resultsFinal/grAll.rds')

# which didn't converge
notConverge <- grAll[which(grAll$gr > 1.1),  ]
notConvergeModels <-  notConverge[!duplicated(notConverge[,-which(colnames(notConverge) %in% 
                                                                    c('gr', 'grUpper', 'param'))]),
                                  c('alarmGen', 'alarmFit',
                                    'infPeriod', 'smoothWindow', 'simNumber')]
notConvergeModels$noConverge <- 1


table(notConvergeModels$alarmGen, 
      notConvergeModels$alarmFit,
      notConvergeModels$smoothWindow)


```



## Posterior parameter estimates 

When correct parametric model was fit to the true data generation process.

```{r}
### load truth
paramsTruth <- read.xlsx('simParamsSummary.xlsx')
paramsTruth <- paramsTruth[paramsTruth$infPeriod == 'fixed',]

### wide to long
paramsTruth <- reshape(paramsTruth, 
  varying = c("beta", "delta", "H", "nu", "x0", "k"), 
  v.names = "truth",
  timevar = "param", 
  times = c("beta", "delta", "H", "nu", "x0", "k"), 
  new.row.names = 1:1000,
  direction = "long")

paramsTruth <- paramsTruth[-which(is.na(paramsTruth$truth)),]
paramsTruth <- paramsTruth[order(paramsTruth$alarmGen, paramsTruth$smoothWindow, paramsTruth$param),]
paramsTruth <- paramsTruth[-which(colnames(paramsTruth) %in% c('infPeriod', 'id'))]

paramsPostAll <- readRDS('./resultsFinal/paramsPostAll.rds')

# only keep rows where alarmGen == alarmFit
paramsPostAll <- paramsPostAll[paramsPostAll$alarmGen == paramsPostAll$alarmFit,]

# merge with truth
paramsPostAll <- merge(paramsPostAll, paramsTruth, by = c('param', 'alarmGen', 'smoothWindow'),
                       all.x = T)

paramsPostAll <- paramsPostAll[order(paramsPostAll$alarmGen, 
                                     paramsPostAll$smoothWindow,
                                     paramsPostAll$simNumber, 
                                     paramsPostAll$param),]


### remove those that did not converge (TEMPORARY)
paramsPostAll <- merge(paramsPostAll, notConvergeModels,
                       by = c('alarmGen', 'alarmFit', 
                              'infPeriod', 'smoothWindow', 'simNumber'),
                       all.x = T)

paramsPostAll$noConverge[is.na(paramsPostAll$noConverge)] <- 0
```


### Threshold Alarm

```{r}
### threshold alarm
ggplot(data = subset(paramsPostAll, alarmFit == 'thresh' & noConverge == 0), 
       aes(x = simNumber, y = mean)) +
    geom_point() + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2) +
    facet_wrap(~smoothWindow + param, nrow = 2, scales = 'free_y',
               labeller = "label_both") +
    labs(x = 'Simulation Number', y = '') 


```

### Hill Alarm

```{r}
### hill alarm
ggplot(data = subset(paramsPostAll, alarmFit == 'hill' & noConverge == 0), 
       aes(x = simNumber, y = mean)) +
    geom_point() + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2) +
    facet_wrap(~smoothWindow + param, nrow = 2, scales = 'free_y',
               labeller = "label_both") +
    labs(x = 'Simulation Number', y = '')
```

### Power Alarm

```{r}
### power alarm
ggplot(data = subset(paramsPostAll, alarmFit == 'power' & noConverge == 0), 
       aes(x = simNumber, y = mean)) +
    geom_point() + 
    geom_errorbar(aes(ymin=lower, ymax=upper), width=.9,
                  position = position_dodge(width = 0.9)) +
    geom_hline(aes(yintercept = truth), col = 'red', linetype = 2) +
    facet_wrap(~smoothWindow + param, nrow = 2, scales = 'free_y',
               labeller = "label_both") + 
    labs(x = 'Simulation Number', y = '')
```



## Posterior for Alarm Function

```{r}
### get parameters for true alarms
paramsTruth <- read.xlsx('simParamsSummary.xlsx')
paramsTruth <- paramsTruth[paramsTruth$infPeriod == 'fixed',]

N <- 1e6

xAlarm <- 0:400
trueAlarmThresh14 <- thresholdAlarm(xAlarm, N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])
trueAlarmThresh30 <- thresholdAlarm(xAlarm, N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)])
trueAlarmHill14 <- hillAlarm(xAlarm, 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])
trueAlarmHill30 <- hillAlarm(xAlarm, 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)])
trueAlarmPower14 <- powerAlarm(xAlarm, N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 14)])
trueAlarmPower30 <- powerAlarm(xAlarm, N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 30)])

trueAlarms <- data.frame(xAlarm = rep(xAlarm, 6),
                               trueAlarm = c(trueAlarmThresh14,
                                             trueAlarmThresh30,
                                             trueAlarmHill14,
                                             trueAlarmHill30,
                                             trueAlarmPower14,
                                             trueAlarmPower30),
                               alarmGen = c(rep('thresh', length(xAlarm)*2),
                                            rep('hill', length(xAlarm)*2),
                                            rep('power', length(xAlarm)*2)),
                               smoothWindow = rep(rep(c(14, 30), each = length(xAlarm)), 3))

### load posterior estimates
alarmAll <- readRDS('./resultsFinal/alarmPostAll.rds')


### remove those that did not converge (TEMPORARY)
alarmAll <- merge(alarmAll, notConvergeModels,
                       by = c('alarmGen', 'alarmFit', 
                              'infPeriod', 'smoothWindow', 'simNumber'),
                       all.x = T)

alarmAll$noConverge[is.na(alarmAll$noConverge)] <- 0


# format for better plotting
alarmAll$alarmFit <- factor(alarmAll$alarmFit,
                            levels = c('spline', 'gp', 'thresh', 'hill', 'power'),
                            labels = c('Spline', 'Gaussian Process', 
                                       'Threshold', 'Hill', 'Power'))



```


### 14-day Smoothing Window

```{r}

### smoothing window 14 days
p1 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 14  & 
                              alarmGen == 'thresh'  & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 14 & alarmGen == 'thresh'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit) 

p2 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 14  & 
                              alarmGen == 'hill'  & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 14 & alarmGen == 'hill'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit)

p3 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 14  & 
                              alarmGen == 'power'  & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 14 & alarmGen == 'power'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit)


grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("14-day smoothing", gp = gpar(fontsize = 18, font = 1)))
```

### 30-day Smoothing Window


```{r}

p1 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 30  & 
                              alarmGen == 'thresh'  & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 30 & alarmGen == 'thresh'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit) 

p2 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 30  & 
                              alarmGen == 'hill'  & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 30 & alarmGen == 'hill'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit)

p3 <- ggplot() +  
    geom_line(data = subset(alarmAll, smoothWindow == 30 & 
                              alarmGen == 'power' & noConverge == 0), 
              aes(x = xAlarm, y = mean, group = simNumber), 
              col = adjustcolor('grey40', alpha = 0.5)) +
    geom_line(data = subset(trueAlarms, smoothWindow == 30 & alarmGen == 'power'), 
              aes(x = xAlarm, y = trueAlarm), col = 'red') +
    facet_wrap(~alarmFit) 

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("30-day smoothing", gp = gpar(fontsize = 18, font = 1)))

```



## Posterior prediction

Difficult to look at for every simulated epidemic. Shown here for first epidemic 
from each scenario.

```{r}

simNumber <- 1

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS(paste0('./Data/thresh_fixed_14.rds'))[simNumber,]
trueCurveThresh30 <- readRDS(paste0('./Data/thresh_fixed_30.rds'))[simNumber,]
trueCurveHill14 <- readRDS(paste0('./Data/hill_fixed_14.rds'))[simNumber,]
trueCurveHill30 <- readRDS(paste0('./Data/hill_fixed_30.rds'))[simNumber,]
trueCurvePower14 <- readRDS(paste0('./Data/power_fixed_14.rds'))[simNumber,]
trueCurvePower30 <- readRDS(paste0('./Data/power_fixed_30.rds'))[simNumber,]

trueCurves <- data.frame(time = rep(1:length(trueCurveThresh14), 6),
                         truth = c(trueCurveThresh14, trueCurveThresh30,
                                   trueCurveHill14, trueCurveHill30,
                                   trueCurvePower14, trueCurvePower30),
                         alarmGen = c(rep('thresh', length(trueCurveThresh14)*2),
                                      rep('hill', length(trueCurveThresh14)*2),
                                      rep('power', length(trueCurveThresh14)*2)),
                         smoothWindow = rep(rep(c(14, 30), each = length(trueCurveThresh14)), 3))

# merge with posterior predictions
postPredAll <- readRDS('./resultsFinal/postPredAll.rds')
postPredAll <- postPredAll[postPredAll$simNumber == simNumber,]

# format for better plotting
postPredAll$alarmFit <- factor(postPredAll$alarmFit,
                            levels = c('basic', 'spline', 'gp', 'thresh', 'hill', 'power'),
                            labels = c('Basic', 'Spline', 'Gaussian Process', 
                                       'Threshold', 'Hill', 'Power'))

```

### 14-day Smoothing Window

```{r}
p1 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'thresh' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 14),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p2 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'hill' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'hill' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'hill' & smoothWindow == 14),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p3 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'power' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'power' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'power' & smoothWindow == 14),
               aes(x = time, ymin = lower, ymax = upper), alpha = 0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("14-day smoothing", gp = gpar(fontsize = 18, font = 1)))

```

### 30-day Smoothing Window

```{r}
p1 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'thresh' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 30),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p2 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'hill' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'hill' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'hill' & smoothWindow == 30),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p3 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'power' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'power' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'power' & smoothWindow == 30),
               aes(x = time, ymin = lower, ymax = upper), alpha = 0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("30-day smoothing", gp = gpar(fontsize = 18, font = 1)))

```


Now for second simulated epidemic

```{r}

simNumber <- 3

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS(paste0('./Data/thresh_fixed_14.rds'))[simNumber,]
trueCurveThresh30 <- readRDS(paste0('./Data/thresh_fixed_30.rds'))[simNumber,]
trueCurveHill14 <- readRDS(paste0('./Data/hill_fixed_14.rds'))[simNumber,]
trueCurveHill30 <- readRDS(paste0('./Data/hill_fixed_30.rds'))[simNumber,]
trueCurvePower14 <- readRDS(paste0('./Data/power_fixed_14.rds'))[simNumber,]
trueCurvePower30 <- readRDS(paste0('./Data/power_fixed_30.rds'))[simNumber,]

trueCurves <- data.frame(time = rep(1:length(trueCurveThresh14), 6),
                         truth = c(trueCurveThresh14, trueCurveThresh30,
                                   trueCurveHill14, trueCurveHill30,
                                   trueCurvePower14, trueCurvePower30),
                         alarmGen = c(rep('thresh', length(trueCurveThresh14)*2),
                                      rep('hill', length(trueCurveThresh14)*2),
                                      rep('power', length(trueCurveThresh14)*2)),
                         smoothWindow = rep(rep(c(14, 30), 
                                                each = length(trueCurveThresh14)), 3))

# merge with posterior predictions
postPredAll <- readRDS('./resultsFinal/postPredAll.rds')
postPredAll <- postPredAll[postPredAll$simNumber == simNumber,]


# format for better plotting
postPredAll$alarmFit <- factor(postPredAll$alarmFit,
                            levels = c('basic', 'spline', 'gp', 'thresh', 'hill', 'power'),
                            labels = c('Basic', 'Spline', 'Gaussian Process', 
                                       'Threshold', 'Hill', 'Power'))
```

### 14-day Smoothing Window

```{r}
p1 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'thresh' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 14),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p2 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'hill' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'hill' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'hill' & smoothWindow == 14),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p3 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'power' & smoothWindow == 14),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'power' & smoothWindow == 14),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'power' & smoothWindow == 14),
               aes(x = time, ymin = lower, ymax = upper), alpha = 0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("14-day smoothing", gp = gpar(fontsize = 18, font = 1)))

```

### 30-day Smoothing Window

```{r}
p1 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'thresh' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'thresh' & smoothWindow == 30),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p2 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'hill' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'hill' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'hill' & smoothWindow == 30),
               aes(x = time, ymin=lower, ymax=upper), alpha=0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

p3 <- ggplot() +
  geom_line(data = subset(trueCurves, alarmGen == 'power' & smoothWindow == 30),
            aes(x = time, y = truth)) + 
   geom_line(data = subset(postPredAll, alarmGen == 'power' & smoothWindow == 30),
            aes(x = time, y = mean), col = 'red', size = 1) + 
   geom_ribbon(data=subset(postPredAll, alarmGen == 'power' & smoothWindow == 30),
               aes(x = time, ymin = lower, ymax = upper), alpha = 0.3, fill = 'red') +
  facet_wrap(~alarmFit, nrow = 1)

grid.arrange(p1, p2, p3, nrow = 3,
             top=textGrob("30-day smoothing", gp = gpar(fontsize = 18, font = 1)))

```


## Posterior for beta[t] when modeled explicitly

For one simulation.

$\beta_t = \beta (1 - a_t)$

```{r}
# beta[t] depends on epidemic trajectory

simNumber <- 1
times <- 1:50

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS(paste0('./Data/thresh_fixed_14.rds'))[simNumber,times]
trueCurveThresh30 <- readRDS(paste0('./Data/thresh_fixed_30.rds'))[simNumber,times]
trueCurveHill14 <- readRDS(paste0('./Data/hill_fixed_14.rds'))[simNumber,times]
trueCurveHill30 <- readRDS(paste0('./Data/hill_fixed_30.rds'))[simNumber,times]
trueCurvePower14 <- readRDS(paste0('./Data/power_fixed_14.rds'))[simNumber,times]
trueCurvePower30 <- readRDS(paste0('./Data/power_fixed_30.rds'))[simNumber,times]


# using epidemic trajectory and true parameters, find value of alarm[t]/beta[t]
paramsTruth <- read.xlsx('simParamsSummary.xlsx')
paramsTruth <- paramsTruth[paramsTruth$infPeriod == 'fixed',]

N <- 1e6
trueAlarmThresh14 <- thresholdAlarm(movingAverage(trueCurveThresh14, 14),
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])
trueAlarmThresh30 <- thresholdAlarm(movingAverage(trueCurveThresh30, 30), 
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)])
trueAlarmHill14 <- hillAlarm(movingAverage(trueCurveHill14, 14), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])
trueAlarmHill30 <- hillAlarm(movingAverage(trueCurveHill30, 30), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)])
trueAlarmPower14 <- powerAlarm(movingAverage(trueCurvePower14, 14), 
                               N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 14)])
trueAlarmPower30 <- powerAlarm(movingAverage(trueCurvePower30, 30),
                               N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 30)])

trueAlarmsSim <- data.frame(time = rep(times, 6),
                               trueAlarm = c(trueAlarmThresh14,
                                             trueAlarmThresh30,
                                             trueAlarmHill14,
                                             trueAlarmHill30,
                                             trueAlarmPower14,
                                             trueAlarmPower30),
                               alarmGen = c(rep('thresh', length(times)*2),
                                            rep('hill', length(times)*2),
                                            rep('power', length(times)*2)),
                               smoothWindow = rep(rep(c(14, 30), each = length(times)), 3))

# from true alarms, get true beta[t]
trueBeta <- trueAlarmsSim
trueBeta$trueBeta <- 0.36 * (1 - trueBeta$trueAlarm)

### load posterior estimates
betaPostAll <- readRDS('./resultsFinal/betaPostAll.rds')
betaPostAll <- betaPostAll[betaPostAll$simNumber == simNumber,]


ggplot() +  
    geom_line(data = subset(betaPostAll,), 
              aes(x = time, y = mean, group = simNumber), 
              col = 'red') +
  geom_ribbon(data=subset(betaPostAll),
               aes(x = time, ymin = lower, ymax = upper), 
              alpha = 0.3, fill = 'red') +
    geom_line(data = subset(trueBeta), 
              aes(x = time, y = trueBeta), col = 'black') +
  facet_wrap(~smoothWindow + alarmGen, nrow = 2, labeller = "label_both")

```


And for another simulation

```{r}
# beta[t] depends on epidemic trajectory

simNumber <- 42
times <- 1:50

# get true epidemic curves for each scenario
trueCurveThresh14 <- readRDS(paste0('./Data/thresh_fixed_14.rds'))[simNumber,times]
trueCurveThresh30 <- readRDS(paste0('./Data/thresh_fixed_30.rds'))[simNumber,times]
trueCurveHill14 <- readRDS(paste0('./Data/hill_fixed_14.rds'))[simNumber,times]
trueCurveHill30 <- readRDS(paste0('./Data/hill_fixed_30.rds'))[simNumber,times]
trueCurvePower14 <- readRDS(paste0('./Data/power_fixed_14.rds'))[simNumber,times]
trueCurvePower30 <- readRDS(paste0('./Data/power_fixed_30.rds'))[simNumber,times]


# using epidemic trajectory and true parameters, find value of alarm[t]/beta[t]
paramsTruth <- read.xlsx('simParamsSummary.xlsx')
paramsTruth <- paramsTruth[paramsTruth$infPeriod == 'fixed',]

N <- 1e6
trueAlarmThresh14 <- thresholdAlarm(movingAverage(trueCurveThresh14, 14),
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 14)])
trueAlarmThresh30 <- thresholdAlarm(movingAverage(trueCurveThresh30, 30), 
                                    N = N, 
                                    delta = paramsTruth$delta[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)],
                                    H = paramsTruth$H[
                                        (paramsTruth$alarmGen == 'thresh' & 
                                             paramsTruth$smoothWindow == 30)])
trueAlarmHill14 <- hillAlarm(movingAverage(trueCurveHill14, 14), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 14)])
trueAlarmHill30 <- hillAlarm(movingAverage(trueCurveHill30, 30), 
                             nu = paramsTruth$nu[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             x0 = paramsTruth$x0[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)],
                             delta = paramsTruth$delta[
                                 (paramsTruth$alarmGen == 'hill' & 
                                      paramsTruth$smoothWindow == 30)])
trueAlarmPower14 <- powerAlarm(movingAverage(trueCurvePower14, 14), 
                               N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 14)])
trueAlarmPower30 <- powerAlarm(movingAverage(trueCurvePower30, 30),
                               N = N, 
                                k = paramsTruth$k[
                                    (paramsTruth$alarmGen == 'power' & 
                                         paramsTruth$smoothWindow == 30)])

trueAlarmsSim <- data.frame(time = rep(times, 6),
                               trueAlarm = c(trueAlarmThresh14,
                                             trueAlarmThresh30,
                                             trueAlarmHill14,
                                             trueAlarmHill30,
                                             trueAlarmPower14,
                                             trueAlarmPower30),
                               alarmGen = c(rep('thresh', length(times)*2),
                                            rep('hill', length(times)*2),
                                            rep('power', length(times)*2)),
                               smoothWindow = rep(rep(c(14, 30), each = length(times)), 3))

# from true alarms, get true beta[t]
trueBeta <- trueAlarmsSim
trueBeta$trueBeta <- 0.36 * (1 - trueBeta$trueAlarm)

### load posterior estimates
betaPostAll <- readRDS('./resultsFinal/betaPostAll.rds')
betaPostAll <- betaPostAll[betaPostAll$simNumber == simNumber,]


ggplot() +  
    geom_line(data = subset(betaPostAll,), 
              aes(x = time, y = mean, group = simNumber), 
              col = 'red') +
  geom_ribbon(data=subset(betaPostAll),
               aes(x = time, ymin = lower, ymax = upper), 
              alpha = 0.3, fill = 'red') +
    geom_line(data = subset(trueBeta), 
              aes(x = time, y = trueBeta), col = 'black') +
  facet_wrap(~smoothWindow + alarmGen, nrow = 2, labeller = "label_both")

```



## WAIC comparisons

### WAIC Summaries

WAIC (introduced by Watanabe, 2010, who calls it the widely applicable information criterion) is a more fully Bayesian approach for estimating the out-of-sample expectation (2), starting with the computed log pointwise posterior predictive density (5) and then adding a correction for effective number of parameters to adjust for overfitting.


WAIC = -2(lppd - pWAIC)

 = -2lppd + 2pWAIC

WAIC: The computed WAIC, on the deviance scale. Smaller values are better when comparing WAIC for two models.

lppd: The log predictive density component of WAIC. Bigger is better.

pWAIC: The pWAIC estimate of the effective number of parameters, computed using the pWAIC2 method of Gelman et al. (2014).

$pWAIC_2 = \sum_{i = 1}^n \text{Var}_{post} \log p(y_i|\theta)$

we compute the posterior variance of the log predictive density for each
data point

```{r}
waicAll <- readRDS('./resultsFinal/waicAll.rds')

### remove those that did not converge (TEMPORARY)
waicAll <- merge(waicAll, notConvergeModels,
                       by = c('alarmGen', 'alarmFit', 
                              'infPeriod', 'smoothWindow', 'simNumber'),
                       all.x = T)

waicAll$noConverge[is.na(waicAll$noConverge)] <- 0


# summaries of WAIC values by model
waicSummaries <- ddply(waicAll, .(alarmGen, alarmFit, smoothWindow), summarize,
                       mean_WAIC = mean(waic[noConverge == 0]),
                       mean_lppd = mean(lppd[noConverge == 0]),
                       mean_pWAIC = mean(pWAIC[noConverge == 0]))
waicSummaries <- waicSummaries[order(waicSummaries$mean_WAIC),]

```


#### Threshold alarm with 14-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'thresh' & smoothWindow == 14)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```

#### Threshold alarm with 30-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'thresh' & smoothWindow == 30)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```

#### Hill alarm with 14-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'hill' & smoothWindow == 14)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```

#### Hill alarm with 30-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'hill' & smoothWindow == 30)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```

#### Power alarm with 14-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'power' & smoothWindow == 14)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```

#### Power alarm with 30-day smoothing window

```{r}
tmp <- subset(waicSummaries, alarmGen == 'power' & smoothWindow == 30)
tmp <- tmp[-which(colnames(tmp) %in% c('alarmGen', 'smoothWindow'))]
kable(tmp, row.names = F)
```



### WAIC Model Selection

```{r}
waicMin <- ddply(waicAll, .(alarmGen, smoothWindow, simNumber), summarize,
                 minWAIC = min(waic[noConverge == 0]))

waicAll <- merge(waicAll, waicMin, by = c('alarmGen', 'smoothWindow', 'simNumber'),
                 all.x = T)

waicSelected <- ddply(waicAll, .(alarmGen, smoothWindow, simNumber), summarize,
                     selected = alarmFit[which(waic == minWAIC)])

waicSelected$selected <- factor(waicSelected$selected,
                                levels = c('thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic'))

waicSelected$alarmGen <- factor(waicSelected$alarmGen,
                                levels = c('thresh', 'hill', 'power'))


```

#### 14-day smoothing window

```{r}
waicTab14 <- with(subset(waicSelected, smoothWindow == 14), 
                 table(selected, alarmGen, exclude = NULL))
waicTab14 <- prop.table(waicTab14, 2)

kable(apply(waicTab14, 2, percent, accuracy =0.2))
```


#### 30-day smoothing window

```{r}
waicTab30 <- with(subset(waicSelected, smoothWindow == 30), 
                 table(selected, alarmGen, exclude = NULL))
waicTab30 <- prop.table(waicTab30, 2)

kable(apply(waicTab30, 2, percent, accuracy =0.2))
```

