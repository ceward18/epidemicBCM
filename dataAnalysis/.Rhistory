setwd("C:/Users/caitl/Documents/Postdoc/epidemicBCM/dataAnalysis")
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
################################################################################
### Peak 1
peak <- 1
# format data and initial values
incData <- nyc$smoothedCases[which(nyc$peak == peak)]
N <- nyc$Population[1]
# use first 5 days as those initially infectious
I0 <- sum(incData[1:5])
incData <- incData[-c(1:5)]
# use cumulative infectious before peak to determine those initially removed
if (peak %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak))
}
R0 <- nyc$cumulativeCases[idxStart - 1]
library(nimble)
source('./scripts/modelFits.R')
samples <- fitAlarmModel(incData=incData, N=N, I0=I0, R0=R0,
infPeriod='fixed', alarmFit='hill',
smoothWindow = 30, seed=1)
debugonce(fitAlarmModel)
samples <- fitAlarmModel(incData=incData, N=N, I0=I0, R0=R0,
infPeriod='fixed', alarmFit='hill',
smoothWindow = 30, seed=1)
source('./scripts/modelCodes.R')
# constants that are the same for all models
S0 <- N - I0 - R0
tau <- length(incData)
lengthI <- 7
# get appropriate model code
modelCode <- get(paste0('SIR_', alarmFit, '_', infPeriod))
# for reproducibility so inits are always the same
set.seed(seed + 3)
modelCode
### constants
n <- 50
maxI <- ceiling(max(movingAverage(incData, smoothWindow)) )
xAlarm <- seq(0, maxI, length.out = n)
constantsList <- list(tau = tau,
N = N,
S0 = S0,
I0 = I0,
probRstar = rep(1/lengthI, lengthI),
bw = smoothWindow,
lengthI = lengthI,
n = n,
xAlarm = xAlarm,
maxI = maxI)
constantsList
I0
1:lengthI
incData
### data
dataList <- list(Istar = incData)
### inits
initsList <- list(beta = runif(1, 0, 1),
delta = runif(1, 0, 1),
nu = runif(1, 0, 10),
x0 = max(rnorm(1, maxI/2, 10), 1))
### MCMC specifications
niter <- 600000
nburn <- 300000
nthin <- 15
### create nimble model
myModel <- nimbleModel(modelCode,
data = dataList,
constants = constantsList,
inits = initsList)
constantsList$probRstar
# get appropriate model code
modelCode <- get(paste0('SIR_', alarmFit, '_', infPeriod))
### create nimble model
myModel <- nimbleModel(modelCode,
data = dataList,
constants = constantsList,
inits = initsList)
modelCode
source('./scripts/modelCodes.R')
# constants that are the same for all models
S0 <- N - I0 - R0
tau <- length(incData)
lengthI <- 7
# get appropriate model code
modelCode <- get(paste0('SIR_', alarmFit, '_', infPeriod))
### create nimble model
myModel <- nimbleModel(modelCode,
data = dataList,
constants = constantsList,
inits = initsList)
library(nimble)
source('./scripts/modelFits.R')
samples <- fitAlarmModel(incData=incData, N=N, I0=I0, R0=R0,
infPeriod='fixed', alarmFit='hill',
smoothWindow = 30, seed=1)
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit)
par(mfrow = c(2,2))
plot(samples[,'beta'], type = 'l')
plot(samples[,'nu'], type = 'l')
plot(samples[,'x0'], type = 'l')
plot(samples[,'delta'], type = 'l')
alarmSamples <- t(samples[,grep('yAlarm', colnames(samples))])
alarmMean <- rowMeans(alarmSamples)
alarmCI <- apply(alarmSamples, 1, quantile, probs = c(0.025, 0.975))
par(mfrow = c(1,1))
plot(xAlarm, alarmMean, type = 'l', main = "posterior for alarm function", ylim = c(0, 1))
lines(xAlarm, alarmCI[1,], lty = 2)
lines(xAlarm, alarmCI[2,], lty = 2)
### constants
n <- 50
maxI <- ceiling(max(movingAverage(incData, smoothWindow)) )
xAlarm <- seq(0, maxI, length.out = n)
par(mfrow = c(1,1))
plot(xAlarm, alarmMean, type = 'l', main = "posterior for alarm function", ylim = c(0, 1))
lines(xAlarm, alarmCI[1,], lty = 2)
lines(xAlarm, alarmCI[2,], lty = 2)
### constants
n <- 50
maxI <- ceiling(max(movingAverage(incData, 30)) )
xAlarm <- seq(0, maxI, length.out = n)
par(mfrow = c(1,1))
plot(xAlarm, alarmMean, type = 'l', main = "posterior for alarm function", ylim = c(0, 1))
lines(xAlarm, alarmCI[1,], lty = 2)
lines(xAlarm, alarmCI[2,], lty = 2)
head(allModels)
dim(allModels)
allModels
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit)
allModels
i <- 1
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
print('Running alarm', alarmFit_i, 'on peak', peak_i)
print(paste('Running alarm', alarmFit_i, 'on peak', peak_i))
head(nyc$smoothedCases)
nyc$smoothedCases
head(nyc)
(idxStart - lengthI + 1):idxStart
idxStart <- 5
(idxStart - lengthI + 1):idxStart
lengthI <- 7
(idxStart - lengthI + 1):idxStart
max(1, (idxStart - lengthI + 1)):idxStart
sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):idxStart])
nyc$cumulativeCases[idxStart] - I0
setwd("C:/Users/caitl/Documents/Postdoc/epidemicBCM/dataAnalysis")
### load libraries
library(parallel)
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
infPeriod <- 'fixed'
# 35 possibilities (7 alarmFits, 5 "peaks")
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit,
infPeriod = infPeriod)
# constants for all models
N <- nyc$Population[1]
lengthI <- 7
i <- 1
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
infPeriod_i <- allModels$infPeriod[i]
print(paste('Running alarm:', alarmFit_i,
', peak:', peak_i,
', infPeriod:', infPeriod_i))
# get data for the specified peak
if (peak == 'full') {
incData <- nyc$smoothedCases
} else {
incData <- nyc$smoothedCases[which(nyc$peak == peak)]
}
# initialize current number of infectious and removed individuals
if (peak %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak))
}
# currently infectious
I0 <- sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):idxStart])
R0 <- nyc$cumulativeCases[idxStart] - I0
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
infPeriod_i <- allModels$infPeriod[i]
print(paste('Running alarm:', alarmFit_i,
', peak:', peak_i,
', infPeriod:', infPeriod_i))
# get data for the specified peak
if (peak_i == 'full') {
incData <- nyc$smoothedCases
} else {
incData <- nyc$smoothedCases[which(nyc$peak == peak_i)]
}
# initialize current number of infectious and removed individuals
if (peak_i %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak_i))
}
# currently infectious
I0 <- sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):idxStart])
R0 <- nyc$cumulativeCases[idxStart] - I0
I0
R0
incData
plot(incData)
peak_i
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData',  'infPeriod_i', 'alarmFit_i',
'N', 'I0', 'R0', 'lengthI'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/modelFits.R')
fitAlarmModel(incData = incDataFit, N = N, I0 = I0, R0 = R0,
lengthI = lengthI, infPeriod = infPeriod_i,
alarmFit = alarmFit_i, smoothWindow = 30,
seed = x)
})
stopCluster(cl)
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData',  'infPeriod_i', 'alarmFit_i',
'N', 'I0', 'R0', 'lengthI'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/modelFits.R')
fitAlarmModel(incData = incData, N = N, I0 = I0, R0 = R0,
lengthI = lengthI, infPeriod = infPeriod_i,
alarmFit = alarmFit_i, smoothWindow = 30,
seed = x)
})
stopCluster(cl)
head(resThree[[1]])
plot(resThree[[1]][,'beta'], type = 'l')
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
alarmFit_i
lines(resThree[[2]][,'beta'], col = 'red')
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'alarm[675]'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'alarm[675]'], col = 'red')
lines(resThree[[3]][,'alarm[675]'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0, 0.001))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0, 0.01))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
source('./scripts/summarizePost.R')
# debugonce(summarizePost)
postSummaries <- summarizePost(resThree = resThree, incData = incData,
alarmFit = alarmFit_i, infPeriod = infPeriod_i,
smoothWindow = smoothWindow_i)
# debugonce(summarizePost)
postSummaries <- summarizePost(resThree = resThree, incData = incData,
alarmFit = alarmFit_i, infPeriod = infPeriod_i,
smoothWindow = 30)
colnames(resThree[[1]])
setwd("C:/Users/caitl/Documents/Postdoc/epidemicBCM/dataAnalysis")
### load libraries
library(parallel)
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
infPeriod <- 'fixed'
# 35 possibilities (7 alarmFits, 5 "peaks")
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit,
infPeriod = infPeriod)
# constants for all models
N <- nyc$Population[1]
lengthI <- 7
i <- 1
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
infPeriod_i <- allModels$infPeriod[i]
print(paste('Running alarm:', alarmFit_i,
', peak:', peak_i,
', infPeriod:', infPeriod_i))
# get data for the specified peak
if (peak_i == 'full') {
incData <- nyc$smoothedCases
} else {
incData <- nyc$smoothedCases[which(nyc$peak == peak_i)]
}
# initialize current number of infectious and removed individuals
if (peak_i %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak_i))
}
# currently infectious
I0 <- sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):idxStart])
R0 <- nyc$cumulativeCases[idxStart] - I0
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData',  'infPeriod_i', 'alarmFit_i',
'N', 'I0', 'R0', 'lengthI'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/modelFits.R')
fitAlarmModel(incData = incData, N = N, I0 = I0, R0 = R0,
lengthI = lengthI, infPeriod = infPeriod_i,
alarmFit = alarmFit_i, smoothWindow = 30,
seed = x)
})
stopCluster(cl)
View(allModels)
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0, 0.01))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
plot(resThree[[1]][,'beta'], type = 'l')
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0.1, 0.3))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0.15, 0.2))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0.15, 0.16))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0, 1))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0.2, .4))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0.4, .6))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0.6, .8))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0, 0.01))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
resThree[[3]][,'H']
tail(resThree[[3]][,'H'])
plot(resThree[[1]][,'H'], type = 'l', ylim = c(0.002, 0.004))
lines(resThree[[2]][,'H'], col = 'red')
lines(resThree[[3]][,'H'], col = 'blue')
allModels
setwd("C:/Users/caitl/Documents/Postdoc/epidemicBCM/dataAnalysis")
i <- 3
### load libraries
library(parallel)
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
infPeriod <- 'fixed'
# 35 possibilities (7 alarmFits, 5 "peaks")
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit,
infPeriod = infPeriod)
# constants for all models
N <- nyc$Population[1]
lengthI <- 7
smoothWindow <- 30
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
infPeriod_i <- allModels$infPeriod[i]
print(paste('Running alarm:', alarmFit_i,
', peak:', peak_i,
', infPeriod:', infPeriod_i))
# get data for the specified peak
if (peak_i == 'full') {
incData <- nyc$smoothedCases
} else {
incData <- nyc$smoothedCases[which(nyc$peak == peak_i)]
}
# initialize current number of infectious and removed individuals
if (peak_i %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak_i))
}
# currently infectious
I0 <- sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):idxStart])
R0 <- nyc$cumulativeCases[idxStart] - I0
I0
startIdx
head(nyc[nyc$peak == 2,])
head(nyc[which(nyc$peak == 2),])
I0
R0
nyc[200:220,]
max(1, (idxStart - lengthI + 1)):idxStart]
max(1, (idxStart - lengthI + 1)):idxStart
head(incData)
nyc$cumulativeCases[idxStart]
I0
plot(incData)
setwd("C:/Users/caitl/Documents/Postdoc/epidemicBCM/dataAnalysis")
### load libraries
library(parallel)
### read data
nyc <- read.csv('./Data/nycClean.csv')
peak <- c('full', '1', '2', '3', '4')
alarmFit <- c( 'thresh', 'hill', 'power', 'gp', 'spline', 'betat', 'basic')
infPeriod <- 'fixed'
# 35 possibilities (7 alarmFits, 5 "peaks")
allModels <- expand.grid(peak = peak,
alarmFit = alarmFit,
infPeriod = infPeriod)
# constants for all models
N <- nyc$Population[1]
lengthI <- 7
smoothWindow <- 30
i
allModels
i <- 13
peak_i <- allModels$peak[i]
alarmFit_i <- allModels$alarmFit[i]
infPeriod_i <- allModels$infPeriod[i]
print(paste('Running alarm:', alarmFit_i,
', peak:', peak_i,
', infPeriod:', infPeriod_i))
# get data for the specified peak
if (peak_i == 'full') {
incData <- nyc$smoothedCases
} else {
incData <- nyc$smoothedCases[which(nyc$peak == peak_i)]
}
# initialize current number of infectious and removed individuals
if (peak_i %in% c('full', '1')) {
idxStart <- 5
} else {
idxStart <- min(which(nyc$peak == peak_i))
}
# currently infectious
I0 <- sum(nyc$smoothedCases[max(1, (idxStart - lengthI + 1)):(idxStart)])
R0 <- nyc$cumulativeCases[idxStart] - I0
# first time point is included in initial values
incData <- incData[-1]
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData',  'infPeriod_i', 'alarmFit_i',
'N', 'I0', 'R0', 'lengthI'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/modelFits.R')
fitAlarmModel(incData = incData, N = N, I0 = I0, R0 = R0,
lengthI = lengthI, infPeriod = infPeriod_i,
alarmFit = alarmFit_i, smoothWindow = smoothWindow,
seed = x)
})
stopCluster(cl)
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('incData',  'infPeriod_i', 'alarmFit_i',
'N', 'I0', 'R0', 'lengthI', 'smoothWindow'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(nimble)
# source relevant scripts
source('./scripts/modelFits.R')
fitAlarmModel(incData = incData, N = N, I0 = I0, R0 = R0,
lengthI = lengthI, infPeriod = infPeriod_i,
alarmFit = alarmFit_i, smoothWindow = smoothWindow,
seed = x)
})
stopCluster(cl)
36000.1330000
36000/1330000
167+221
plot(resThree[[1]][,'beta'], type = 'l', ylim = c(0.15, 0.16))
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'beta'], type = 'l')
lines(resThree[[2]][,'beta'], col = 'red')
lines(resThree[[3]][,'beta'], col = 'blue')
plot(resThree[[1]][,'delta'], type = 'l', ylim = c(0.6, .8))
lines(resThree[[2]][,'delta'], col = 'red')
lines(resThree[[3]][,'delta'], col = 'blue')
alarmFit_i
plot(resThree[[1]][,'k'], type = 'l')
lines(resThree[[2]][,'k'], col = 'red')
lines(resThree[[3]][,'k'], col = 'blue')
